//////////////////////////////////////////////////////////////////////
/// \mainpage TabStrip Documentation
///
/// \section intro_sec Introduction
///
/// %TabStrip is an ActiveX control that wraps the \c SysTabControl32 window class. It is optimized for
/// Visual Basic 6.0, but should also work in any other environment that supports COM controls.
///
/// \section basics_sec Basics
///
/// The control superclasses the native tabstrip window class of Windows: \c SysTabControl32. Although
/// I tried to wrap all features of this window class (status: Windows 10), some things may be missing.
/// In these cases you usually may use the Win32 API and handle the control as a native tabstrip window.
/// One of my goals was it to create a tabstrip control that may be controlled via API as well as via the
/// classes that I implemented.
///
/// \section reqs_sec Requirements
///
/// %TabStrip ANSI runs on the following operating systems:
/// - Windows XP (SP3 or later)
/// - Windows Server 2003 (SP2 or later)
/// - Windows Vista (SP2 or later)
/// - Windows Server 2008 (SP2 or later)
/// - Windows 7 (SP1 or later)
/// - Windows Server 2008 R2 (SP1 or later)
/// - Windows 8
/// - Windows Server 2012
/// - Windows 8.1
/// - Windows Server 2012 R2
/// - Windows 10
/// - Windows Server 2016
///
/// Some features have additional requirements which are mentioned in the affected feature's
/// documentation.\n
/// Limited support means, that I won't invest much work to support those systems. If a feature works on
/// a system marked with "limited support" - fine; if it does not and it's easy to fix, I'll fix it, but if
/// it's difficult to fix, I probably won't fix it. Also I will test the control much less on those systems.
///
/// \section support_sec Support
///
/// There's no entitlement to support. Period. However, you have good chances to get help if you post your
/// questions on <a href="https://github.com/TimoKunze/TabStripControl">GitHub</a> or in the
/// <a href="https://www.timosoft-software.de/forum/viewforum.php?f=26">forums</a>.\n
/// Also the project is open source, so feel free to have a look at the source code. You may modify it, but
/// please consider sharing your changes with the rest of the world.
///
/// \section lic_sec License
///
/// <pre>
///      MIT License
///
///      Copyright (c) 2006-2018 Timo Kunze
///
///      Permission is hereby granted, free of charge, to any person obtaining a copy
///      of this software and associated documentation files (the "Software"), to deal
///      in the Software without restriction, including without limitation the rights
///      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
///      copies of the Software, and to permit persons to whom the Software is
///      furnished to do so, subject to the following conditions:
///
///      The above copyright notice and this permission notice shall be included in all
///      copies or substantial portions of the Software.
///
///      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
///      SOFTWARE.
/// </pre>
///
/// \section acks_sec Acknowledgements
///
/// Thanks go to:
/// - <a href="https://www.winehq.com">Wine Headquarters</a>, because Wine helped me a lot on
///   understanding how Windows is working.
/// - Microsoft, for ATL, WTL and Visual Studio - great libraries and a great IDE
/// - <a href="https://www.geoffchappell.com">Geoff Chappell</a>, for his website about undocumented Win32
///   API stuff.
/// - Igor Tandetnik, for his great help on learning ATL and WTL
/// - Dimitri van Heesch, for Doxygen
/// - <a href="http://www.zabkat.com/">Nikos Bozinis</a>, for his awesome help with the Vista drag'n'drop
///   stuff.
/// - <a href="https://www.dateicommander.de">Christian LÃ¼tgens</a>, for his great work as beta-tester
///   and for his help when I needed a 2nd opinion on some decisions.
/// - All donators
/// - For great music: Heaven Shall Burn, Arch Enemy, Machine Head, Trivium, Deadlock, Draconian, Soulfly,
///   Delain, Lacuna Coil, Ensiferum, Epica, Sirenia, Tristania, Nightwish, Battlelore, Amon Amarth, Volbeat,
///   Guns N' Roses
///
/// \section faq_sec FAQ
///
/// <strong>1. Why is the \c Font property ignored?</strong>\n
/// It isn't. My controls have a property \c UseSystemFont which defaults to \c True. This property tells
/// the control to use the system font rather than the font set by the \c Font property.\n
/// Why is this property's default \c True? Well, if I set system wide settings (like fonts) I expect all
/// applications to follow them. Unfortunately ignoring system wide settings seems to be trendy, so see
/// my decision as an educational measure.
///
/// <strong>2. Why is event xyz not fired?</strong>\n
/// Firing an event is relative time-consuming, even if the event isn't handled by the application at all.
/// Therefore I implemented a \c DisabledEvents property which can be used to deactivate certain events.\n
/// By default many events are deactivated.
///
/// <strong>4. The control has drawing glitches if it sits inside a Visual Basic 6 Frame control and the app is themed!</strong>\n
/// The intrinsic Frame control of Visual Basic 6.0 doesn't work well with Windows themes. The drawing
/// glitches you see are more a problem of the Frame control than of the TabStrip control. So far I have
/// not found any work-around for the drawing glitches, that doesn't come with other side-effects like
/// extreme flicker on control resize.\n
/// Until a better solution is found, you should make sure that you always place the TabStrip control
/// inside a container which has its own device context (it should have a hDC property then).\n
/// Adequate replacements for the Visual Basic 6 Frame control are the Frame control from my ButtonControls
/// library and the PictureBox control, depending on your requirements.
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
/// \namespace TabStripCtlLibA
/// \brief <em>Contains COM definitions for the control's public interface</em>
///
/// This is the ANSI version of the TabStrip COM library.
//////////////////////////////////////////////////////////////////////


#include "olectl.h"
#include "CompilerFlags.h"
#include "DispIDs.h"

#ifndef DOXYGEN_SHOULD_SKIP_THIS
	// interface is not automation marshaling conformant, requires Windows NT 4.0 SP4 or greater
	midl_pragma warning(disable: 2039)
	// identifier length exceeds 31 characters
	midl_pragma warning(disable: 2111)
	// too many methods in the interface, requires Windows NT 4.0 SP3 or greater
	midl_pragma warning(disable: 2362)
#endif

import "oaidl.idl";
import "ocidl.idl";


[
	uuid(3DF28271-B5ED-46F4-9EFF-E60A4CDD0D02),
	version(1.10),
	helpstring("TimoSoft TabStrip 1.10 (ANSI)")
]
library TabStripCtlLibA
{
	importlib("stdole2.tlb");


	/// \brief <em>Constants used with the \c Appearance property</em>
	///
	/// \sa ITabStrip::Appearance
	[helpstring("Constants used with the 'Appearance' property.")]
	typedef enum AppearanceConstants {
		/// \brief The control is drawn with a flat border
		[helpstring("The control is drawn flat.")]
		a2D,
		/// \brief The control is drawn with a normal 3D border
		[helpstring("The control is drawn with a normal 3D border.")]
		a3D,
		/// \brief The control is drawn with a light 3D border
		[helpstring("The control is drawn with a light 3D border.")]
		a3DLight
	} AppearanceConstants;

	/// \brief <em>Constants used with the \c BorderStyle property</em>
	///
	/// \sa ITabStrip::BorderStyle
	[helpstring("Constants used with the 'BorderStyle' property.")]
	typedef enum BorderStyleConstants {
		/// \brief The control is drawn without an inner border
		[helpstring("The control is drawn without an additional border.")]
		bsNone,
		/// \brief The control is drawn with an inner border
		[helpstring("The control is drawn with an additional border.")]
		bsFixedSingle
	} BorderStyleConstants;

	/// \brief <em>Constants used with the \c CloseableTabsMode property</em>
	///
	/// \sa ITabStrip::CloseableTabsMode
	[helpstring("Constants used with the 'CloseableTabsMode' property.")]
	typedef enum CloseableTabsModeConstants {
		//ctmNoCloseableTabs = 0?
		/// \brief Each tab is drawn with a close button
		[helpstring("Each tab is drawn with a close button.")]
		ctmDisplayOnAllTabs = 1,
		/// \brief Only the active tab is drawn with a close button
		[helpstring("Only the active tab is drawn with a close button.")]
		ctmDisplayOnActiveTab = 2
		//ctmDisplayInTabHeaderRow = 3?
	} CloseableTabsModeConstants;

	/// \brief <em>Flags used with the \c DisabledEvents property</em>
	///
	/// \sa ITabStrip::DisabledEvents
	[helpstring("Flags used with the 'DisabledEvents' property. They can be combined.")]
	typedef enum DisabledEventsConstants {
		/// \brief Mouse events won't be fired
		///
		/// The following events won't be fired: \c MouseDown, \c MouseUp, \c MClick, \c MouseEnter,
		/// \c MouseHover, \c MouseLeave, \c TabMouseEnter, \c TabMouseLeave, \c MouseMove
		///
		/// \attention Because the MouseDown and MouseUp events are required to provide the MClick event,
		///            it won't be fired anymore, too.
		///
		/// \sa _ITabStripEvents::MouseDown, _ITabStripEvents::MouseUp, _ITabStripEvents::MClick,
		///     _ITabStripEvents::MouseEnter, _ITabStripEvents::MouseHover, _ITabStripEvents::MouseLeave,
		///     _ITabStripEvents::TabMouseEnter, _ITabStripEvents::TabMouseLeave, _ITabStripEvents::MouseMove
		[helpstring("Disables the following events: MouseDown, MouseUp, MClick, MouseEnter, MouseHover, MouseLeave, TabMouseEnter, TabMouseLeave, MouseMove")]
		deMouseEvents = 0x01,
		/// \brief Click events won't be fired
		///
		/// The following events won't be fired: \c Click, \c DblClick, \c MClick, \c MDblClick,
		/// \c RClick, \c RDblClick, \c XClick, \c XDblClick
		///
		/// \sa _ITabStripEvents::Click, _ITabStripEvents::DblClick, _ITabStripEvents::MClick,
		///     _ITabStripEvents::MDblClick, _ITabStripEvents::RClick, _ITabStripEvents::RDblClick,
		///     _ITabStripEvents::XClick, _ITabStripEvents::XDblClick
		[helpstring("Disables the following events: Click, DblClick, MClick, MDblClick, RClick, RDblClick, XClick, XDblClick")]
		deClickEvents = 0x02,
		/// \brief Keyboard events won't be fired
		///
		/// The following events won't be fired: \c KeyDown, \c KeyUp, \c KeyPress
		///
		/// \sa _ITabStripEvents::KeyDown, _ITabStripEvents::KeyUp, _ITabStripEvents::KeyPress
		[helpstring("Disables the following events: KeyDown, KeyUp, KeyPress")]
		deKeyboardEvents = 0x08,
		/// \brief Events concerning tab-insertions won't be fired
		///
		/// The following events won't be fired: \c InsertingTab, \c InsertedTab
		///
		/// \sa _ITabStripEvents::InsertingTab, _ITabStripEvents::InsertedTab
		[helpstring("Disables the following events: InsertingTab, InsertedTab")]
		deTabInsertionEvents = 0x20,
		/// \brief Events concerning tab-deletions won't be fired
		///
		/// The following events won't be fired: \c RemovingTab, \c RemovedTab
		///
		/// \sa _ITabStripEvents::RemovingTab, _ITabStripEvents::RemovedTab
		[helpstring("Disables the following events: RemovingTab, RemovedTab")]
		deTabDeletionEvents = 0x40,
		/// \brief The \c FreeTabData event won't be fired
		///
		/// The following event won't be fired: \c FreeTabData
		///
		/// \sa _ITabStripEvents::FreeTabData
		[helpstring("Disables the following event: FreeTabData")]
		deFreeTabData = 0x80,
		/// \brief The \c TabSelectionChanged event won't be fired
		///
		/// The following event won't be fired: \c TabSelectionChanged
		///
		/// \sa _ITabStripEvents::TabSelectionChanged
		[helpstring("Disables the following event: TabSelectionChanged")]
		deTabSelectionChanged = 0x40000
	} DisabledEventsConstants;

	/// \brief <em>Constants used with the \c IOLEDataObject::GetDropDescription and IOLEDataObject::SetDropDescription methods</em>
	///
	/// \sa IOLEDataObject::GetDropDescription, IOLEDataObject::SetDropDescription
	[helpstring("Constants used with the 'OLEDataObject.GetDropDescription' and 'OLEDataObject.SetDropDescription' methods.")]
	typedef enum DropDescriptionIconConstants {
		/// \brief No drop description is displayed
		[helpstring("No drop description is displayed.")]
		ddiNone = -1/*DROPIMAGE_INVALID*/,     // should be 8 (DROPIMAGE_NOIMAGE)
		/// \brief The drop description icon that visualizes the \c odeNone drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeNone' drop effect is displayed.")]
		ddiNoDrop = 0/*DROPIMAGE_NONE*/,
		/// \brief The drop description icon that visualizes the \c odeCopy drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeCopy' drop effect is displayed.")]
		ddiCopy = 1/*DROPIMAGE_COPY*/,
		/// \brief The drop description icon that visualizes the \c odeMove drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeMove' drop effect is displayed.")]
		ddiMove = 2/*DROPIMAGE_MOVE*/,
		/// \brief The drop description icon that visualizes the \c odeLink drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeLink' drop effect is displayed.")]
		ddiLink = 4/*DROPIMAGE_LINK*/,
		/// \brief The drop description icon that visualizes a drop, which causes a metadata change, is displayed
		[helpstring("The drop description icon that visualizes a drop, which causes a metadata change, is displayed.")]
		ddiMetadataChange = 6/*DROPIMAGE_LABEL*/,
		/// \brief The drop description icon that visualizes a warning is displayed
		[helpstring("The drop description icon that visualizes a warning is displayed.")]
		ddiWarning = 7/*DROPIMAGE_WARNING*/,
		/// \brief The default drop description is displayed
		///
		/// \remarks Requires Windows 7 or newer.
		[helpstring("The default drop description is displayed. Requires Windows 7 or newer.")]
		ddiUseDefault = 8/*DROPIMAGE_NOIMAGE*/     // should be -1 (DROPIMAGE_INVALID)
	} DropDescriptionIconConstants;

	/// \brief <em>Constants used with the extended mouse button events</em>
	///
	/// \sa _ITabStripEvents::MouseDown, _ITabStripEvents::MouseEnter, _ITabStripEvents::MouseHover,
	///     _ITabStripEvents::MouseLeave, _ITabStripEvents::MouseMove, _ITabStripEvents::MouseUp,
	///     _ITabStripEvents::TabMouseEnter, _ITabStripEvents::TabMouseLeave,
	///     _ITabStripEvents::XClick, _ITabStripEvents::XDblClick
	[helpstring("Constants used with the extended mouse button events.")]
	typedef enum ExtendedMouseButtonConstants {
		/// \brief Identifies the first extended mouse button
		[helpstring("Identifies the first extended mouse button.")]
		embXButton1 = 0x20,
		/// \brief Identifies the second extended mouse button
		[helpstring("Identifies the second extended mouse button.")]
		embXButton2 = 0x40
	} ExtendedMouseButtonConstants;

	/// \brief <em>Constants used with the \c ITabStripTabs::Filter property</em>
	///
	/// \sa ITabStripTabs::Filter
	[helpstring("Constants used with the 'TabStripTab.Filter' property.")]
	typedef enum FilteredPropertyConstants {
		/// \brief Retrieve or set the filter that filters by the \c IconIndex property
		///
		/// \sa ITabStripTab::IconIndex
		[helpstring("Retrieve or set the filter that filters by the 'IconIndex' property.")]
		fpIconIndex = 4,
		/// \brief Retrieve or set the filter that filters by the \c Index property
		///
		/// \sa ITabStripTab::Index
		[helpstring("Retrieve or set the filter that filters by the 'Index' property.")]
		fpIndex = 6,
		/// \brief Retrieve or set the filter that filters by the \c TabData property
		///
		/// \sa ITabStripTab::TabData
		[helpstring("Retrieve or set the filter that filters by the 'TabData' property.")]
		fpTabData = 7,
		/// \brief Retrieve or set the filter that filters by the \c Selected property
		///
		/// \sa ITabStripTab::Selected
		[helpstring("Retrieve or set the filter that filters by the 'Selected' property.")]
		fpSelected = 9,
		/// \brief Retrieve or set the filter that filters by the \c Text property
		///
		/// \sa ITabStripTab::Text
		[helpstring("Retrieve or set the filter that filters by the 'Text' property.")]
		fpText = 11
	} FilteredPropertyConstants;

	/// \brief <em>Constants used with the \c ITabStripTabs::FilterType property</em>
	///
	/// \sa ITabStripTabs::FilterType
	[helpstring("Constants used with the 'TabStripTabs.FilterType' property.")]
	typedef enum FilterTypeConstants {
		/// \brief The filter is deactivated
		[helpstring("The filter is deactivated.")]
		ftDeactivated,
		/// \brief An item must match this filter to be in the collection
		[helpstring("An item must match this filter to be in the collection.")]
		ftIncluding,
		/// \brief An item must not match this filter to be in the collection
		[helpstring("An item must not match this filter to be in the collection.")]
		ftExcluding
	} FilterTypeConstants;

	/// \brief <em>Flags used with the \c HitTest method</em>
	///
	/// \sa ITabStrip::HitTest
	[helpstring("Flags used with the 'HitTest' method.")]
	typedef enum HitTestConstants {
		/// \brief Not over a tab
		///
		/// The specified point lies not on a tab.
		[helpstring("The specified point not on a tab.")]
		htNotOverTab = 0x0001 /*TCHT_NOWHERE*/,
		/// \brief On a tab's icon
		///
		/// The specified point lies on a tab's icon.
		[helpstring("The specified point lies on a tab's icon.")]
		htTabIcon = 0x0002 /*TCHT_ONITEMICON*/,
		/// \brief On a tab's label
		///
		/// The specified point lies on a tab's text label.
		[helpstring("The specified point lies on a tab's text label.")]
		htTabLabel = 0x0004 /*TCHT_ONITEMLABEL*/,
		/// \brief On a tab
		///
		/// The specified point lies on a tab's icon or text label.
		[helpstring("The specified point lies on a tab's icon or text label.")]
		htTab = 0x0006 /*TCHT_ONITEM*/,
		/// \brief Above the control's window rectangle
		///
		/// The specified point lies above the control's window rectangle.
		[helpstring("The specified point lies above the control's window rectangle.")]
		htAbove = 0x0100 /*TCHT_ABOVE*/,
		/// \brief Below the control's window rectangle
		///
		/// The specified point lies below the control's window rectangle.
		[helpstring("The specified point lies below the control's window rectangle.")]
		htBelow = 0x0200 /*TCHT_BELOW*/,
		/// \brief To the right of the control's window rectangle
		///
		/// The specified point lies to the right of the control's window rectangle.
		[helpstring("The specified point lies to the right of the control's window rectangle.")]
		htToRight = 0x0400 /*TCHT_TORIGHT*/,
		/// \brief To the left of the control's window rectangle
		///
		/// The specified point lies to the left of the control's window rectangle.
		[helpstring("The specified point lies to the left of the control's window rectangle.")]
		htToLeft = 0x0800 /*TCHT_TOLEFT*/,
		/// \brief In the control's client area
		///
		/// The specified point lies in the control's client area.
		[helpstring("The specified point lies in the control's client area.")]
		htClientArea = 0x1000 /*TCHT_CLIENTAREA*/,
		/// \brief In a close button's bounding rectangle
		///
		/// The specified point lies in the bounding rectangle of one of the control's close buttons.
		[helpstring("The specified point lies in the bounding rectangle of one of the control's close buttons.")]
		htCloseButton = 0x2000 /*TCHT_CLOSEBUTTON*/
	} HitTestConstants;

	/// \brief <em>Constants that may be used with the \c SetInsertMarkPosition and \c GetInsertMarkPosition methods</em>
	///
	/// Constants that may be used for the \c relativePosition parameter of the \c SetInsertMarkPosition
	/// and \c GetInsertMarkPosition methods.
	///
	/// \sa ITabStrip::SetInsertMarkPosition, ITabStrip::GetInsertMarkPosition
	[helpstring("Constants that may be used for the 'relativePosition' parameter of the 'SetInsertMarkPosition' and 'GetInsertMarkPosition' methods.")]
	typedef enum InsertMarkPositionConstants {
		/// \brief The insertion mark is or will be removed
		[helpstring("The insertion mark is or will be removed.")]
		impNowhere = 0,
		/// \brief The insertion mark is or will be placed before the tab
		[helpstring("The insertion mark is or will be placed before the tab.")]
		impBefore = 1,
		/// \brief The insertion mark is or will be placed after the tab
		[helpstring("The insertion mark is or will be placed after the tab.")]
		impAfter = 2,
		/// \brief The insertion mark won't be (re-)moved
		[helpstring("The insertion mark won't be (re-)moved.")]
		impDontChange = 3
	} InsertMarkPositionConstants;

	/// \brief <em>Constants used with the \c MousePointer property</em>
	///
	/// \sa ITabStrip::MousePointer
	[helpstring("Constants used with the 'MousePointer' property.")]
	typedef enum MousePointerConstants {
		/// \brief The default mouse cursor is used
		[helpstring("The default mouse cursor is used.")]
		mpDefault,
		/// \brief The default arrow is used as mouse cursor
		[helpstring("The default arrow is used as mouse cursor.")]
		mpArrow,
		/// \brief A cross is used as mouse cursor
		[helpstring("A cross is used as mouse cursor.")]
		mpCross,
		/// \brief A vertical beam (like in textboxes) is used as mouse cursor
		[helpstring("A vertical beam (like in textboxes) is used as mouse cursor.")]
		mpIBeam,
		/// \brief An icon is used as mouse cursor
		[helpstring("An icon is used as mouse cursor.")]
		mpIcon,
		/// \brief A mouse cursor indicating window sizing is used
		[helpstring("A mouse cursor indicating window sizing is used.")]
		mpSize,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-right or lower-left corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-right or lower-left corner is used.")]
		mpSizeNESW,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its upper or
		/// lower border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper or lower border is used.")]
		mpSizeNS,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-left or lower-right corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-left or lower-right corner is used.")]
		mpSizeNWSE,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its left or
		/// right border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's left or right border is used.")]
		mpSizeEW,
		/// \brief An arrow pointing upwardly is used as mouse cursor
		[helpstring("An arrow pointing upwardly is used as mouse cursor.")]
		mpUpArrow,
		/// \brief An hourglass is used as mouse cursor.
		[helpstring("An hourglass is used as mouse cursor.")]
		mpHourglass,
		/// \brief An mouse cursor indicating that the control can't be a drop target is used
		[helpstring("An mouse cursor indicating that the control can't be a drop target is used.")]
		mpNoDrop,
		/// \brief The default arrow with a small hourglass is used as mouse cursor
		[helpstring("The default arrow with a small hourglass is used as mouse cursor.")]
		mpArrowHourglass,
		/// \brief The default arrow with a small question mark is used as mouse cursor
		[helpstring("The default arrow with a small question mark is used as mouse cursor.")]
		mpArrowQuestion,
		/// \brief A mouse cursor indicating window sizing to all directions is used
		[helpstring("A mouse cursor indicating window sizing to all directions is used.")]
		mpSizeAll,
		/// \brief A hand typically used for hyperlinks is used as mouse cursor
		[helpstring("A hand typically used for hyperlinks is used as mouse cursor.")]
		mpHand,
		/// \brief A mouse cursor indicating that the program waits for some media is used
		[helpstring("A mouse cursor indicating that the program waits for some media is used.")]
		mpInsertMedia,
		/// \brief A mouse cursor indicating scrolling to all directions is used
		[helpstring("A mouse cursor indicating scrolling to all directions is used.")]
		mpScrollAll,
		/// \brief A mouse cursor indicating scrolling upwardly is used
		[helpstring("A mouse cursor indicating scrolling upwardly is used.")]
		mpScrollN,
		/// \brief A mouse cursor indicating scrolling to the window's upper-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-right corner is used.")]
		mpScrollNE,
		/// \brief A mouse cursor indicating scrolling to the window's right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's right border is used.")]
		mpScrollE,
		/// \brief A mouse cursor indicating scrolling to the window's lower-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-right corner is used.")]
		mpScrollSE,
		/// \brief A mouse cursor indicating scrolling downwards is used
		[helpstring("A mouse cursor indicating scrolling downwards is used.")]
		mpScrollS,
		/// \brief A mouse cursor indicating scrolling to the window's lower-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-left corner is used.")]
		mpScrollSW,
		/// \brief A mouse cursor indicating scrolling to the window's left border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left border is used.")]
		mpScrollW,
		/// \brief A mouse cursor indicating scrolling to the window's upper-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-left corner is used.")]
		mpScrollNW,
		/// \brief A mouse cursor indicating scrolling upwardly or downwards is used
		[helpstring("A mouse cursor indicating scrolling upwardly or downwards is used.")]
		mpScrollNS,
		/// \brief A mouse cursor indicating scrolling to the window's left or right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left or right border is used.")]
		mpScrollEW,
		/// \brief The custom mouse cursor defined by the \c MouseIcon property is used
		[helpstring("The custom mouse cursor defined by the MouseIcon property is used.")]
		mpCustom = 0x63
	} MousePointerConstants;

	/// \brief <em>Constants used with the \c OLEQueryContinueDrag event</em>
	///
	/// \sa _ITabStripEvents::OLEQueryContinueDrag, _ITabStripEvents::OLEGiveFeedback,
	///     ITabStrip::OLEDrag
	[helpstring("Constants used with the OLEQueryContinueDrag event.")]
	typedef enum OLEActionToContinueWithConstants {
		/// \brief Continue the drag'n'drop operation
		[helpstring("Continue the drag'n'drop operation.")]
		oatcwContinue = 0x0 /*S_OK*/,
		/// \brief Cancel the drag'n'drop operation
		[helpstring("Cancel the drag'n'drop operation.")]
		oatcwCancel = 0x40101 /*DRAGDROP_S_CANCEL*/,
		/// \brief Complete the drag'n'drop operation
		[helpstring("Complete the drag'n'drop operation.")]
		oatcwDrop = 0x40100 /*DRAGDROP_S_DROP*/
	} OLEActionToContinueWithConstants;

	/// \brief <em>Constants used with the \c OLEDragImageStyle property</em>
	///
	/// \sa ITabStrip::OLEDragImageStyle
	[helpstring("Constants used with the 'OLEDragImageStyle' property.")]
	typedef enum OLEDragImageStyleConstants {
		/// \brief OLE drag images will be generated in classic style
		[helpstring("OLE drag images will be generated in classic style.")]
		odistClassic,
		/// \brief OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems
		///
		/// \remarks Aero style is supported by Windows Vista and newer systems.\n
		///          The icons for Aero style drag images are taken from the \c hHighResImageList image list.
		///
		/// \sa ITabStrip::hHighResImageList
		[helpstring("OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems. Aero style is supported by Windows Vista and newer systems.")]
		odistAeroIfAvailable
	} OLEDragImageStyleConstants;

	/// \brief <em>Constants used with OLE drag'n'drop</em>
	///
	/// \sa _ITabStripEvents::OLEDragEnter, _ITabStripEvents::OLEDragMouseMove, _ITabStripEvents::OLEDragDrop
	[helpstring("Constants used with the OLEDrag* events.")]
	typedef enum OLEDropEffectConstants {
		/// \brief No OLE drag and drop operation has occurred or will occur
		[helpstring("No OLE drag and drop operation has occurred or will occur.")]
		odeNone = 0 /*DROPEFFECT_NONE*/,
		/// \brief A copy has occured or will occur
		[helpstring("A copy has occured or will occur.")]
		odeCopy = 1 /*DROPEFFECT_COPY*/,
		/// \brief A move has occured or will occur
		[helpstring("A move has occured or will occur.")]
		odeMove = 2 /*DROPEFFECT_MOVE*/,
		/// \brief A link has occured or will occur
		[helpstring("A link has occured or will occur.")]
		odeLink = 4 /*DROPEFFECT_LINK*/,
		/// \brief Combination of \c odeCopy and \c odeMove
		[helpstring("Combination of 'odeCopy' and 'odeMove'.")]
		odeCopyOrMove = odeCopy | odeMove,
		/// \brief The drop target window has scrolled or will scroll
		[helpstring("The drop target window has scrolled or will scroll.")]
		odeScroll = 0x80000000 /*DROPEFFECT_SCROLL*/
	} OLEDropEffectConstants;

	/// \brief <em>Flags used to identify tab states during owner-drawing</em>
	///
	/// \sa _ITabStripEvents::OwnerDrawTab
	[helpstring("Flags used to identify tab states during owner-drawing.")]
	typedef enum OwnerDrawTabStateConstants {
		/// \brief The tab is selected
		[helpstring("The tab is selected.")]
		odtsSelected = 0x1 /*ODS_SELECTED*/
	} OwnerDrawTabStateConstants;

	/// \brief <em>Constants used with the \c RegisterForOLEDragDrop property</em>
	///
	/// \sa ITabStrip::RegisterForOLEDragDrop
	[helpstring("Constants used with the 'RegisterForOLEDragDrop' property.")]
	typedef enum RegisterForOLEDragDropConstants {
		/// \brief OLE drag'n'drop support is deactivated
		[helpstring("OLE drag'n'drop support is deactivated.")]
		rfoddNoDragDrop,
		/// \brief The built-in OLE drag'n'drop support of \c SysTabControl32 is used
		///
		/// The built-in OLE drag'n'drop support of \c SysTabControl32 is used. The control automatically
		/// highlights the tab below the mouse cursor.
		[helpstring("The built-in OLE drag'n'drop support of 'SysTabControl32' is used. The control automatically highlights the tab below the mouse cursor.")]
		rfoddNativeDragDrop,
		/// \brief OLE drag'n'drop is done by the \c TabStrip class
		///
		/// OLE drag'n'drop is done by the \c TabStrip class, giving the client application full control over
		/// OLE drag'n'drop.
		[helpstring("OLE drag'n'drop is done by the 'TabStrip' class, giving the client application full control over OLE drag'n'drop.")]
		rfoddAdvancedDragDrop
	} RegisterForOLEDragDropConstants;

	/// \brief <em>Flags used with the \c RightToLeft property</em>
	///
	/// \sa ITabStrip::RightToLeft
	[helpstring("Flags used with the 'RightToLeft' property. They can be combined.")]
	typedef enum RightToLeftConstants {
		/// \brief Read text from right to left
		///
		/// The tabs' text is read from right to left, but the general layout is left to right, e. g. the
		/// arrow buttons for tab scrolling are displayed on the control's right side.
		[helpstring("The tabs' text is read from right to left, but the general layout is left to right, e. g. the arrow buttons for tab scrolling are displayed on the control's right side.")]
		rtlText = 1,
		/// \brief Use a right to left layout
		///
		/// The general layout is right to left, e. g. the arrow buttons for tab scrolling are displayed on
		/// the control's left side.
		[helpstring("The general layout is right to left, e. g. the arrow buttons for tab scrolling are displayed on the control's left side.")]
		rtlLayout = 2
	} RightToLeftConstants;

	/// \brief <em>Constants used with the \c Style property</em>
	///
	/// \sa ITabStrip::Style
	[helpstring("Constants used with the 'Style' property.")]
	typedef enum StyleConstants {
		/// \brief The tabs appear as tabs
		[helpstring("The tabs appear as tabs.")]
		sTabs,
		/// \brief The tabs appear as buttons and no border is drawn around the client area
		[helpstring("The tabs appear as buttons and no border is drawn around the client area.")]
		sButtons,
		/// \brief The tabs appear as flat buttons and no border is drawn around the client area
		///
		/// \sa ITabStrip::ShowButtonSeparators, ITabStrip::FocusOnButtonDown
		[helpstring("The tabs appear as flat buttons and no border is drawn around the client area.")]
		sFlatButtons
	} StyleConstants;

	/// \brief <em>Flags used with the \c TabBoundingBoxDefinition property</em>
	///
	/// \sa ITabStrip::TabBoundingBoxDefinition
	[helpstring("Flags used with the 'TabBoundingBoxDefinition' property. They can be combined.")]
	typedef enum TabBoundingBoxDefinitionConstants {
		/// \brief A tab's icon is handled as part of the tab
		[helpstring("A tab's icon is handled as part of the tab.")]
		tbbdTabIcon = htTabIcon,
		/// \brief A tab's text label is handled as part of the tab
		[helpstring("A tab's text label is handled as part of the tab.")]
		tbbdTabLabel = htTabLabel,
		/// \brief A tab's close button is handled as part of the tab
		[helpstring("A tab's close button is handled as part of the tab.")]
		tbbdTabCloseButton = htCloseButton
	} TabBoundingBoxDefinitionConstants;

	/// \brief <em>Constants used with the \c TabCaptionAlignment property</em>
	///
	/// \sa ITabStrip::TabCaptionAlignment
	[helpstring("Constants used with the 'TabCaptionAlignment' property.")]
	typedef enum TabCaptionAlignmentConstants {
		/// \brief The tab's icon and text are centered
		[helpstring("The tab's icon and text are centered.")]
		tcaNormal,
		/// \brief The tab's icon is left-aligned
		[helpstring("The tab's icon is left-aligned.")]
		tcaForceIconLeft,
		/// \brief The tab's icon and text are left-aligned
		[helpstring("The tab's icon and text are left-aligned.")]
		tcaForceCaptionLeft
	} TabCaptionAlignmentConstants;

	/// \brief <em>Constants used to identify tabs within an \c ITabStripTabs collection</em>
	///
	/// \sa ITabStripTabs
	[helpstring("Constants used to identify tabs within a 'TabStripTabs' collection.")]
	typedef enum TabIdentifierTypeConstants {
		/// \brief The tab is identified by an unique ID
		///
		/// A tab's ID will never change.
		///
		/// \sa ITabStripTab::ID
		[helpstring("The tab is identified by an unique ID.")]
		titID,
		/// \brief The tab is identified by a zero-based index
		///
		/// Reordering the tabs won't change a tab's index, but removing or adding new tabs may do so.
		///
		/// \remarks This is the preferred and fastest method to identify a tab.
		///
		/// \sa ITabStripTab::Index
		[helpstring("The tab is identified by a zero-based index.")]
		titIndex
	} TabIdentifierTypeConstants;

	/// \brief <em>Constants used with the \c TabPlacement property</em>
	///
	/// \sa ITabStrip::TabPlacement
	[helpstring("Constants used with the 'TabPlacement' property.")]
	typedef enum TabPlacementConstants {
		/// \brief The tabs appear at the top of the control
		[helpstring("The tabs appear at the top of the control.")]
		tpTop,
		/// \brief The tabs appear at the bottom of the control
		///
		/// \remarks This value doesn't work well for themed tabstrips.
		[helpstring("The tabs appear at the bottom of the control. This value doesn't work well for themed tabstrips.")]
		tpBottom,
		/// \brief The tabs appear at the left side of the control
		///
		/// \remarks This value doesn't work well for themed tabstrips.
		[helpstring("The tabs appear at the left side of the control. This value doesn't work well for themed tabstrips.")]
		tpLeft,
		/// \brief The tabs appear at the right side of the control
		///
		/// \remarks This value doesn't work well for themed tabstrips.
		[helpstring("The tabs appear at the right side of the control. This value doesn't work well for themed tabstrips.")]
		tpRight
	} TabPlacementConstants;


	/// \brief <em>Holds the coordinates of a rectangle's opposing corners</em>
	///
	/// \sa _ITabStripEvents::OwnerDrawTab, ITabStrip::CalculateDisplayArea,
	///     ITabStrip::CalculateWindowRectangle
	// NOTE: If we change the UUID, we also need to update _ITabStripEvents_CP.h!
	[helpstring("Holds a rectangle's position and size."), uuid(90A884B3-C35D-44db-9710-5F694CBBCDA1)]
	typedef struct RECTANGLE
	{
		/// \brief <em>Holds the position of the rectangle's left border in pixels</em>
		[helpstring("Holds the position of the rectangle's left border in pixels.")]
		OLE_XPOS_PIXELS Left;
		/// \brief <em>Holds the position of the rectangle's upper border in pixels</em>
		[helpstring("Holds the position of the rectangle's upper border in pixels.")]
		OLE_YPOS_PIXELS Top;
		/// \brief <em>Holds the position of the rectangle's right border in pixels</em>
		[helpstring("Holds the position of the rectangle's right border in pixels.")]
		OLE_XPOS_PIXELS Right;
		/// \brief <em>Holds the position of the rectangle's lower border in pixels</em>
		[helpstring("Holds the position of the rectangle's lower border in pixels.")]
		OLE_YPOS_PIXELS Bottom;
	} RECTANGLE;


	/// \interface IVirtualTabStripTab
	/// \brief <em>Wraps a not existing tab</em>
	///
	/// This interface is a wrapper around a tabstrip tab that does not yet or not anymore exist within
	/// the control.
	///
	/// \sa _IVirtualTabStripTabEvents, ITabStripTab, _ITabStripEvents
	[
		object,
		uuid(D7B74ED3-D24D-4393-A256-F63C9EFA5007),
		dual,
		nonextensible,
		helpstring("IVirtualTabStripTab interface"),
		pointer_default(unique)
	]
	interface IVirtualTabStripTab : IDispatch
	{
		/// \brief <em>Retrieves whether the tab is highlighted as drop target</em>
		///
		/// Retrieves whether the tab will be or was drawn as the target of a drag'n'drop operation,
		/// i. e. whether its background will be or was highlighted. If this property is set to \c True,
		/// the tab will be or was highlighted; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ITabStrip::DropHilitedTab, Selected
		[propget, id(DISPID_VTST_DROPHILITED), helpstring("Retrieves whether the tab is highlighted as a target of a drag'n'drop operation.")]
		HRESULT DropHilited([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the tab's icon</em>
		///
		/// Retrieves the zero-based index of the tab's icon in the control's imagelist identified by
		/// \c ITabStrip::hImageList. If set to -1, no icon is displayed for this tab.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ITabStrip::hImageList
		[propget, id(DISPID_VTST_ICONINDEX), helpstring("Retrieves the zero-based index of the tab's icon in the control's imagelist identified by 'TabStrip.hImageList'. If set to -1, no icon is displayed for this tab."), nonbrowsable]
		HRESULT IconIndex([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the tab's zero-based index</em>
		///
		/// Retrieves the zero-based index that will identify or has identified the tab.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ITabStripTabs::Add
		[propget, id(DISPID_VTST_INDEX), helpstring("Retrieves the tab's zero-based index."), nonbrowsable]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Retrieves whether the tab is selected</em>
		///
		/// Retrieves whether the tab will be or was drawn as a selected tab. If this property is set to
		/// \c True, the tab will be or was selected; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa DropHilited, ITabStrip::MultiSelect, ITabStrip::ActiveTab, ITabStrip::CaretTab
		[propget, id(DISPID_VTST_SELECTED), helpstring("Retrieves whether the tab is drawn as a selected tab.")]
		HRESULT Selected([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the tab's associated data</em>
		///
		/// Retrieves the \c Long value that will be or was associated with the tab.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _ITabStripEvents::FreeTabData
		[propget, id(DISPID_VTST_TABDATA), helpstring("Retrieves the Long value associated with the tab.")]
		HRESULT TabData([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the tab's text</em>
		///
		/// Retrieves the tab's text. The maximum number of characters in this text is 8192.
		///
		/// \remarks This is the default property of the \c IVirtualTabStripTab interface.\n
		///          This property is read-only.
		///
		/// \sa ITabStripTabs::Add
		[propget, id(DISPID_VTST_TEXT), helpstring("Retrieves the tab's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
	}


	/// \interface ITabStripTab
	/// \brief <em>Wraps an existing tab</em>
	///
	/// This interface is a wrapper around a tabstrip tab that - unlike an item wrapped by
	/// \c IVirtualTabStripTab - really exists within the control.
	///
	/// \sa _ITabStripTabEvents, IVirtualTabStripTab, ITabStripTabs, ITabStripTabContainer, ITabStrip,
	///     _ITabStripEvents
	[
		object,
		uuid(9599A777-6903-4adf-8E10-7BF65BB62E00),
		dual,
		nonextensible,
		helpstring("ITabStripTab interface"),
		pointer_default(unique)
	]
	interface ITabStripTab : IDispatch
	{
		/// \brief <em>Retrieves whether the tab is the control's active tab</em>
		///
		/// Retrieves whether the tab is the control's active tab, i. e. it's the tab whose content is
		/// currently displayed. If it is the active tab, this property is set to \c True; otherwise it's set
		/// to \c False.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Caret, Selected, ITabStrip::ActiveTab
		[propget, id(DISPID_TST_ACTIVE), helpstring("Retrieves whether the tab is the current active tab, i. e. it's the tab whose content is currently displayed.")]
		HRESULT Active([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the tab is the control's caret tab</em>
		///
		/// Retrieves whether the tab is the control's caret tab, i. e. it has the keyboard focus. If it is the
		/// caret tab, this property is set to \c True; otherwise it's set to \c False.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Active, Selected, ITabStrip::CaretTab
		[propget, id(DISPID_TST_CARET), helpstring("Retrieves whether the tab is the current caret tab, i. e. it has the keyboard focus.")]
		HRESULT Caret([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the tab is highlighted as drop target</em>
		///
		/// Retrieves whether the tab is drawn as the target of a drag'n'drop operation, i. e. whether
		/// its background is highlighted. If this property is set to \c True, the tab is highlighted;
		/// otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ITabStrip::DropHilitedTab, Selected
		[propget, id(DISPID_TST_DROPHILITED), helpstring("Retrieves whether the tab is highlighted as a target of a drag'n'drop operation.")]
		HRESULT DropHilited([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the tab's height</em>
		///
		/// Retrieves the height (in pixels) of the tab's bounding rectangle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Left, Top, Width, ITabStrip::DisplayAreaHeight
		[propget, id(DISPID_TST_HEIGHT), helpstring("Retrieves the height (in pixels) of the tab's bounding rectangle.")]
		HRESULT Height([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Specifies the tab's icon</em>
		///
		/// Retrieves or sets the zero-based index of the tab's icon in the control's imagelist identified by
		/// \c ITabStrip::hImageList. If set to -1, no icon is displayed for this tab.
		///
		/// \sa ITabStrip::hImageList
		[propget, id(DISPID_TST_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the tab's icon in the control's imagelist identified by 'TabStrip.hImageList'. If set to -1, no icon is displayed for this tab."), nonbrowsable]
		HRESULT IconIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_TST_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the tab's icon in the control's imagelist identified by 'TabStrip.hImageList'. If set to -1, no icon is displayed for this tab."), nonbrowsable]
		HRESULT IconIndex([in] LONG newValue);
		/// \brief <em>Retrieves the tab's ID</em>
		///
		/// Retrieves an unique ID identifying this tab.
		///
		/// \remarks A tab's ID will never change.\n
		///          This property is read-only.
		///
		/// \sa Index, TabIdentifierTypeConstants
		[propget, id(DISPID_TST_ID), helpstring("Retrieves the tab's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		/// \brief <em>Specifies the tab's zero-based index</em>
		///
		/// Retrieves or sets the zero-based index identifying this tab. Setting this property moves the tab.
		///
		/// \remarks Although adding or removing tabs changes other tabs' indexes, the index is the best
		///          (and fastest) option to identify a tab.
		///
		/// \sa ID, TabIdentifierTypeConstants
		[propget, id(DISPID_TST_INDEX), helpstring("Retrieves or sets the zero-based index identifying this tab. Setting this property moves the tab.")]
		HRESULT Index([out, retval] LONG* pValue);
		[propput, id(DISPID_TST_INDEX), helpstring("Retrieves or sets the zero-based index identifying this tab. Setting this property moves the tab.")]
		HRESULT Index([in] LONG newValue);
		/// \brief <em>Retrieves the x-coordinate of the tab's bounding rectangle</em>
		///
		/// Retrieves the distance (in pixels) between the control's left border and the left border of the
		/// tab's bounding rectangle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Top, Height, Width
		[propget, id(DISPID_TST_LEFT), helpstring("Retrieves the distance (in pixels) between the control's left border and the left border of the tab's bounding rectangle.")]
		HRESULT Left([out, retval] OLE_XPOS_PIXELS* pValue);
		/// \brief <em>Specifies whether the tab is selected</em>
		///
		/// Retrieves or sets whether the tab is drawn as a selected tab. If this property is set to \c True,
		/// the tab is selected; otherwise not.
		///
		/// \sa Active, Caret, DropHilited, ITabStrip::MultiSelect, ITabStrip::ActiveTab, ITabStrip::CaretTab
		[propget, id(DISPID_TST_SELECTED), helpstring("Retrieves or sets whether the tab is drawn as a selected tab.")]
		HRESULT Selected([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TST_SELECTED), helpstring("Retrieves or sets whether the tab is drawn as a selected tab.")]
		HRESULT Selected([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the tab's associated data</em>
		///
		/// Retrieves or sets the \c Long value associated with the tab. Use this property to associate
		/// any data with the tab.
		///
		/// \sa _ITabStripEvents::FreeTabData
		[propget, id(DISPID_TST_TABDATA), helpstring("Retrieves or sets the Long value associated with the tab.")]
		HRESULT TabData([out, retval] LONG* pValue);
		[propput, id(DISPID_TST_TABDATA), helpstring("Retrieves or sets the Long value associated with the tab.")]
		HRESULT TabData([in] LONG newValue);
		/// \brief <em>Specifies the tab's text</em>
		///
		/// Retrieves or sets the tab's text. The maximum number of characters in this text is 8192.
		///
		/// \remarks This is the default property of the \c ITabStripTab interface.
		///
		/// \sa ITabStripTabs::Add
		[propget, id(DISPID_TST_TEXT), helpstring("Retrieves or sets the tab's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_TST_TEXT), helpstring("Retrieves or sets the tab's text.")]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Retrieves the y-coordinate of the tab's bounding rectangle</em>
		///
		/// Retrieves the distance (in pixels) between the control's top border and the top border of the
		/// tab's bounding rectangle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Left, Height, Width
		[propget, id(DISPID_TST_TOP), helpstring("Retrieves the distance (in pixels) between the control's top border and the top border of the tab's bounding rectangle.")]
		HRESULT Top([out, retval] OLE_YPOS_PIXELS* pValue);
		/// \brief <em>Retrieves the tab's width</em>
		///
		/// Retrieves the width (in pixels) of the tab's bounding rectangle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Left, Top, Height, ITabStrip::DisplayAreaWidth
		[propget, id(DISPID_TST_WIDTH), helpstring("Retrieves the width (in pixels) of the tab's bounding rectangle.")]
		HRESULT Width([out, retval] OLE_XSIZE_PIXELS* pValue);

		/// \brief <em>Retrieves an imagelist containing the tab's drag image</em>
		///
		/// Retrieves the handle to an imagelist containing a bitmap that can be used to visualize
		/// dragging of this tab.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return The handle to the imagelist containing the bitmap.
		///
		/// \remarks The caller is responsible for destroying the imagelist.
		[id(DISPID_TST_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an imagelist containing a bitmap that can be used to visualize dragging of this tab.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);

		/// \brief <em>Specifies the window associated with the tab</em>
		///
		/// Retrieves or sets the handle of the window associated with the tab. The window will be made visible
		/// automatically if the tab is selected and it will be hidden automatically if the tab is deselected.
		///
		/// \remarks Window hiding takes place after the \c ActiveTabChanging event. The newly activated tab's
		///          associated window is made visible before the \c ActiveTabChanged event.
		///
		/// \sa _ITabStripEvents::ActiveTabChanging, _ITabStripEvents::ActiveTabChanged
		[propget, id(DISPID_TST_HASSOCIATEDWINDOW), helpstring("Retrieves or sets the handle of the window associated with the tab. The window will be made visible automatically if the tab is selected and it will be hidden automatically if the tab is deselected."), nonbrowsable]
		HRESULT hAssociatedWindow([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_TST_HASSOCIATEDWINDOW), helpstring("Retrieves or sets the handle of the window associated with the tab. The window will be made visible automatically if the tab is selected and it will be hidden automatically if the tab is deselected."), nonbrowsable]
		HRESULT hAssociatedWindow([in] OLE_HANDLE newValue);
		/// \brief <em>Specifies whether the tab has a button for closing it</em>
		///
		/// Retrieves or sets whether the tab has a button for closing it. If set to \c True, the tab has a
		/// close button; otherwise not.
		///
		/// \sa ITabStrip::CloseableTabs
		[propget, id(DISPID_TST_HASCLOSEBUTTON), helpstring("Retrieves or sets whether the tab has a button for closing it."), nonbrowsable]
		HRESULT HasCloseButton([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TST_HASCLOSEBUTTON), helpstring("Retrieves or sets whether the tab has a button for closing it."), nonbrowsable]
		HRESULT HasCloseButton([in] VARIANT_BOOL newValue);
	}


	/// \interface ITabStripTabs
	/// \brief <em>Manages a collection of \c TabStripTab objects</em>
	///
	/// This interface provides easy access (including filtering) to collections of \c TabStripTab
	/// objects. While a \c TabStripTabContainer object is used to group any tabs and acts more like
	/// a clipboard, a \c TabStripTabs object is used to group tabs that have certain properties in
	/// common.
	///
	/// \sa _ITabStripTabsEvents, ITabStripTab, ITabStripTabContainer, ITabStrip
	[
		object,
		uuid(1D4BB4D3-E0F6-4a51-817E-39CC6FA12164),
		dual,
		nonextensible,
		helpstring("ITabStripTabs interface"),
		pointer_default(unique)
	]
	interface ITabStripTabs : IDispatch
	{
		/// \brief <em>Specifies whether filters for string properties are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are done when applying the filters on a tab,
		/// are case sensitive. If this property is set to \c True, string comparisons are case sensitive;
		/// otherwise not.
		///
		/// \sa Filter, ComparisonFunction
		[propget, id(DISPID_TSTS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on a tab, are case sensitive.")]
		HRESULT CaseSensitiveFilters([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TSTS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on a tab, are case sensitive.")]
		HRESULT CaseSensitiveFilters([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies a filter's comparison function</em>
		///
		/// Retrieves or sets a tab filter's comparison function. This property takes the address of a
		/// function having the following signature:
		/// \code
		///   IsEqual(ByVal tabProperty As T, ByVal pattern As T) As Long
		/// \endcode
		/// where T stands for the filtered property's type (\c Boolean, \c Long or \c String). This function
		/// must compare its arguments and return a non-zero value if the arguments are equal and zero
		/// otherwise.\n
		/// If this property is set to 0, the control compares the values itself using the "=" operator
		/// (\c lstrcmp and \c lstrcmpi for string filters).
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, CaseSensitiveFilters, FilteredPropertyConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647488.aspx">lstrcmp</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647489.aspx">lstrcmpi</a>
		[propget, id(DISPID_TSTS_COMPARISONFUNCTION), helpstring("Retrieves or sets a tab filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [out, retval] LONG* pValue);
		[propput, id(DISPID_TSTS_COMPARISONFUNCTION), helpstring("Retrieves or sets a tab filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [in] LONG newValue);
		/// \brief <em>Specifies a filter for a property</em>
		///
		/// Retrieves or sets a tab filter.\n
		/// An \c ITabStripTabs collection can be filtered by any of \c ITabStripTab's properties, that
		/// the \c FilteredPropertyConstants enumeration defines a constant for. Combinations of multiple
		/// filters are possible, too. A filter is a \c Variant containing an array whose elements are of
		/// type \c Variant. Each element of this array contains a valid value for the property, that the
		/// filter refers to.\n
		/// When applying the filter, the elements of the array are connected using the logical Or operator.\n\n
		/// Setting this property to \c Empty or any other value, that doesn't match the described structure,
		/// deactivates the filter.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa FilterType, ComparisonFunction, FilteredPropertyConstants
		[propget, id(DISPID_TSTS_FILTER), helpstring("Retrieves or sets a tab filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [out, retval] VARIANT* pValue);
		[propput, id(DISPID_TSTS_FILTER), helpstring("Retrieves or sets a tab filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [in] VARIANT newValue);
		/// \brief <em>Specifies a filter's type</em>
		///
		/// Retrieves or sets a tab filter's type.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, FilteredPropertyConstants, FilterTypeConstants
		[propget, id(DISPID_TSTS_FILTERTYPE), helpstring("Retrieves or sets a tab filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [out, retval] FilterTypeConstants* pValue);
		[propput, id(DISPID_TSTS_FILTERTYPE), helpstring("Retrieves or sets a tab filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [in] FilterTypeConstants newValue);
		/// \brief <em>Retrieves a \c TabStripTab object from the collection</em>
		///
		/// Retrieves a \c TabStripTab object from the collection that wraps the tab identified by
		/// \c tabIdentifier.
		///
		/// \param[in] tabIdentifier A value that identifies the tabstrip tab to be retrieved.
		/// \param[in] tabIdentifierType A value specifying the meaning of \c tabIdentifier. Any of the
		///            values defined by the \c TabIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c ITabStripTabs interface.\n
		///          This property is read-only.
		///
		/// \sa ITabStripTab, TabIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_TSTS_ITEM), helpstring("Retrieves a 'TabStripTab' object from the collection that wraps the tab identified by 'tabIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG tabIdentifier, [in, defaultvalue(titIndex)] TabIdentifierTypeConstants tabIdentifierType, [out, retval] ITabStripTab** ppTab);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c TabStripTab objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_TSTS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds a tab to the tabstrip</em>
		///
		/// Adds a tab with the specified properties at the specified position in the control and returns
		/// a \c TabStripTab object wrapping the inserted tab.
		///
		/// \param[in] tabText The new tab's caption text. The maximum number of characters in this text
		///            is 8192.
		/// \param[in] insertAt The new tab's zero-based index. If set to -1, the tab will be inserted
		///            as the last tab.
		/// \param[in] iconIndex The zero-based index of the tab's icon in the control's imagelist
		///            identified by \c ITabStrip::hImageList. If set to -1, no icon will be displayed for
		///            the new tab.
		/// \param[in] tabData A \c Long value that will be associated with the tab.
		///
		/// \return The inserted tab.
		///
		/// \sa Count, Remove, RemoveAll, ITabStripTab::Text, ITabStripTab::IconIndex, ITabStripTab::TabData,
		///     ITabStrip::hImageList
		[id(DISPID_TSTS_ADD), helpstring("Adds a new tab with the specified properties.")]
		HRESULT Add([in] BSTR tabText, [in, defaultvalue(-1)] LONG insertAt, [in, defaultvalue(-1)] LONG IconIndex, [in, defaultvalue(0)] LONG TabData, [out, retval] ITabStripTab** ppAddedTab);
		/// \brief <em>Retrieves whether the specified tab is part of the tab collection</em>
		///
		/// \param[in] tabIdentifier A value that identifies the tab to be checked.
		/// \param[in] tabIdentifierType A value specifying the meaning of \c tabIdentifier. Any of the
		///            values defined by the \c TabIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified tab is part of the collection; otherwise \c False.
		///
		/// \sa Filter, Add, Remove, TabIdentifierTypeConstants
		[id(DISPID_TSTS_CONTAINS), helpstring("Retrieves whether the specified tab is part of the tab collection.")]
		HRESULT Contains([in] LONG tabIdentifier, [in, defaultvalue(titIndex)] TabIdentifierTypeConstants tabIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the tabs in the collection</em>
		///
		/// Retrieves the number of \c TabStripTab objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_TSTS_COUNT), helpstring("Retrieves the number of 'TabStripTab' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the selection from all tabs in the collection</em>
		///
		/// Sets the \c Selected property of all \c TabStripTab objects in the collection to \c False.
		///
		/// \param[in] keepActiveTabSelected If \c True, the control's active tab remains selected; otherwise
		///            it is deselected as well.
		///
		/// \sa ITabStripTab::Selected, ITabStrip::MultiSelect, ITabStrip::ActiveTab
		[id(DISPID_TSTS_DESELECTALL), helpstring("Removes the selection from all tabs in the collection.")]
		HRESULT DeselectAll([in, defaultvalue(0)] VARIANT_BOOL keepActiveTabSelected);
		/// \brief <em>Removes the specified tab in the collection from the tabstrip</em>
		///
		/// \param[in] tabIdentifier A value that identifies the tabstrip tab to be removed.
		/// \param[in] tabIdentifierType A value specifying the meaning of \c tabIdentifier. Any of the
		///            values defined by the \c TabIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, TabIdentifierTypeConstants
		[id(DISPID_TSTS_REMOVE), helpstring("Removes the specified tab in the collection from the control.")]
		HRESULT Remove([in] LONG tabIdentifier, [in, defaultvalue(titIndex)] TabIdentifierTypeConstants tabIdentifierType);
		/// \brief <em>Removes all tabs in the collection from the tabstrip</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_TSTS_REMOVEALL), helpstring("Removes all tabs in the collection from the control.")]
		HRESULT RemoveAll(void);
	}


	/// \interface ITabStripTabContainer
	/// \brief <em>Manages a collection of \c TabStripTab objects</em>
	///
	/// This interface provides easy access to collections of \c TabStripTab objects. While a
	/// \c TabStripTabs object is used to group tabs that have certain properties in common, a
	/// \c TabStripTabContainer object is used to group any tabs and acts more like a clipboard.
	///
	/// \sa _ITabStripTabContainerEvents, ITabStripTab, ITabStripTabs, ITabStrip
	[
		object,
		uuid(5573853E-5CAE-4881-A569-C77D27D0D6E9),
		dual,
		nonextensible,
		helpstring("ITabStripTabContainer interface"),
		pointer_default(unique)
	]
	interface ITabStripTabContainer : IDispatch
	{
		/// \brief <em>Retrieves a \c TabStripTab object from the collection</em>
		///
		/// Retrieves a \c TabStripTab object from the collection that wraps the tab identified by \c tabID.
		///
		/// \param[in] tabID The unique ID of the tab to retrieve.
		///
		/// \remarks This is the default property of the \c ITabStripTabContainer interface.\n
		///          This property is read-only.
		///
		/// \sa ITabStripTab::ID, Add, Remove
		[propget, id(DISPID_TSTC_ITEM), helpstring("Retrieves a 'TabStripTab' object from the collection that wraps the tab identified by 'tabID'."), nonbrowsable]
		HRESULT Item([in] LONG tabID, [out, retval] ITabStripTab** ppTab);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c TabStripTab objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_TSTC__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds the specified tab(s) to the collection</em>
		///
		/// \param[in] Tabs The tab(s) to add. May be either a tab ID, a \c TabStripTab object or a
		///            \c TabStripTabs collection.
		///
		/// \sa ITabStripTab::ID, Count, Remove, RemoveAll
		[id(DISPID_TSTC_ADD), helpstring("Adds the specified tab(s) to the collection.")]
		HRESULT Add([in] VARIANT Tabs);
		/// \brief <em>Clones the collection object</em>
		///
		/// Retrieves an exact copy of the collection.
		///
		/// \return The cloned object.
		///
		/// \sa ITabStrip::CreateTabContainer
		[id(DISPID_TSTC_CLONE), helpstring("Creates an exact copy of the collection.")]
		HRESULT Clone([out, retval] ITabStripTabContainer** ppClone);
		/// \brief <em>Counts the tabs in the collection</em>
		///
		/// Retrieves the number of \c TabStripTab objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_TSTC_COUNT), helpstring("Retrieves the number of 'TabStripTab' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Retrieves an imagelist containing the tabs' common drag image</em>
		///
		/// Retrieves the handle to an imagelist containing a bitmap that can be used to visualize
		/// dragging of the tabs of this collection.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return: The handle to the imagelist containing the bitmap.
		///
		/// \remarks The caller is responsible for destroying the imagelist.
		[id(DISPID_TSTC_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an imagelist containing a bitmap that can be used to visualize dragging of the tabs of this collection.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);
		/// \brief <em>Removes the specified tab from the collection</em>
		///
		/// \param[in] tabID The unique ID of the tab to remove.
		/// \param[in] removePhysically If \c True, the tab is removed from the control, too.
		///
		/// \sa ITabStripTab::ID, Add, Count, RemoveAll
		[id(DISPID_TSTC_REMOVE), helpstring("Removes the specified tab from the collection.")]
		HRESULT Remove([in] LONG tabID, [in, defaultvalue(0)] VARIANT_BOOL removePhysically);
		/// \brief <em>Removes all tabs from the collection</em>
		///
		/// \param[in] removePhysically If \c True, the items are removed from the control, too.
		///
		/// \sa Add, Count, Remove
		[id(DISPID_TSTC_REMOVEALL), helpstring("Removes all tabs from the collection.")]
		HRESULT RemoveAll([in, defaultvalue(0)] VARIANT_BOOL removePhysically);
	}


	/// \interface IOLEDataObject
	/// \brief <em>Wraps the \c IDataObject interface</em>
	///
	/// This interface provides easy access to data being transferred using the \c IDataObject interface.
	///
	/// \sa _IOLEDataObjectEvents,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
	[
		object,
		uuid(396D282E-257B-434e-B01A-7302EB35669F),
		dual,
		nonextensible,
		helpstring("IOLEDataObject interface"),
		pointer_default(unique)
	]
	interface IOLEDataObject : IDispatch
	{
		/// \brief <em>Deletes the contents of the \c OLEDataObject object</em>
		///
		/// \remarks This method will succeed only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
		[id(DISPID_ODO_CLEAR), helpstring("Deletes the contents of the 'OLEDataObject' object.")]
		HRESULT Clear(void);
		/// \brief <em>Retrieves the best format settings from the \c OLEDataObject object</em>
		///
		/// Call this method to retrieve data format settings that match best with the data format, that you
		/// actually want to work with. Set the parameters to the data format settings you want to work with.
		/// The method will set them to the settings you should use.
		///
		/// \param[in,out] formatID An integer value specifying the data format. Valid values are those defined
		///                by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///                registered using the \c RegisterClipboardFormat API function.
		/// \param[in,out] index An integer value that is assigned to the internal \c FORMATETC struct's
		///                \c lindex member. Usually you pass -1 here, but some formats like
		///                \c CFSTR_FILECONTENTS require multiple \c FORMATETC structs for the same format. In
		///                such cases you'll give each struct of this format a separate index.
		/// \param[in,out] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
		///                struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
		///                Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \sa GetData, GetFormat,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETCANONICALFORMAT), helpstring("Call this method to retrieve data format settings that match best with the data format, that you actually want to work with.")]
		HRESULT GetCanonicalFormat([in, out] LONG* formatID, [in, out] LONG* Index, [in, out] LONG* dataOrViewAspect);
		/// \brief <em>Retrieves data from the \c OLEDataObject object</em>
		///
		/// Retrieves data from the \c OLEDataObject object, that has the specified format.
		///
		/// \param[in] formatID An integer value specifying the format of the data to retrieve. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return The data that has the specified format.
		///
		/// \remarks This method will fail, if the \c OLEDataObject object does not contain data of the
		///          specified format.
		///
		/// \sa GetCanonicalFormat, GetFormat, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETDATA), helpstring("Retrieves data from the 'OLEDataObject' object.")]
		HRESULT GetData([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT* pData);
		/// \brief <em>Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object</em>
		///
		/// Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object. The drop description
		/// describes what will happen if the user drops the dragged data at the current position. It is
		/// displayed at the bottom of the drag image.
		///
		/// \param[in,out] targetDescription Receives the description of the current drop target.
		/// \param[in,out] actionDescription Receives the description of the whole drop action, i. e. a string
		///                like <em>"Copy to %1"</em> where <em>"Copy to"</em> is the description of the current
		///                drop effect and <em>"%1"</em> is the placeholder for the drop target description
		///                specified by \c targetDescription.
		/// \param[in,out] icon Receives the icon used to visualize the current drop effect. Any of the values
		///                defined by the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa SetDropDescription, ITabStrip::SupportOLEDragImages, DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_GETDROPDESCRIPTION), helpstring("Retrieves the 'DROPDESCRIPTION' data stored by the 'OLEDataObject' object. Requires Windows Vista or newer.")]
		HRESULT GetDropDescription([in, out, optional] VARIANT* targetDescription, [in, out, optional] VARIANT* actionDescription, [in, out, defaultvalue(0)] DropDescriptionIconConstants* Icon);
		/// \brief <em>Retrieves whether the \c OLEDataObject object contains data in a specific format</em>
		///
		/// \param[in] formatID An integer value specifying the format to check for. Valid values are those
		///            defined by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///            registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return \c True, if the \c OLEDataObject object contains data in the specified format;
		///         otherwise \c False.
		///
		/// \sa GetCanonicalFormat, GetData, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETFORMAT), helpstring("Retrieves whether the 'OLEDataObject' object contains data in a specific format.")]
		HRESULT GetFormat([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT_BOOL* pFormatAvailable);
		/// \brief <em>Inserts data into the \c OLEDataObject object using the specified format</em>
		///
		/// \param[in] formatID An integer value specifying the format of the data being passed. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] data The data to insert. If not specified, the \c OLESetData event will be raised if
		///            data of the specified format is requested from the \c OLEDataObject object.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \remarks The \c data parameter is optional only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa GetData, Clear, _ITabStripEvents::OLESetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_SETDATA), helpstring("Inserts data into the 'OLEDataObject' object using the specified format.")]
		HRESULT SetData([in] LONG formatID, [in, optional] VARIANT data, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect);
		/// \brief <em>Sets the drop description displayed below the drag image</em>
		///
		/// Sets the \c DROPDESCRIPTION data. The drop description describes what will happen if the user drops
		/// the dragged data at the current position. It is displayed at the bottom of the drag image.
		///
		/// \param[in] targetDescription The description of the current drop target.
		/// \param[in] actionDescription The description of the whole drop action, i. e. a string like <em>"Copy
		///            to %1"</em> where <em>"Copy to"</em> is the description of the current drop effect and
		///            <em>"%1"</em> is the placeholder for the drop target description specified by
		///            \c targetDescription.
		/// \param[in] icon The icon used to visualize the current drop effect. Any of the values defined by
		///            the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa GetDropDescription, ITabStrip::SupportOLEDragImages, DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_SETDROPDESCRIPTION), helpstring("Sets the drop description displayed below the drag image. Requires Windows Vista or newer.")]
		HRESULT SetDropDescription([in, optional] VARIANT targetDescription, [in, optional] VARIANT actionDescription, [in, defaultvalue(ddiNone)] DropDescriptionIconConstants Icon);
	}


	/// \interface ITabStrip
	/// \brief <em>The main interface</em>
	///
	/// This is the control's main interface. It wraps the control window.
	///
	/// \sa _ITabStripEvents, ITabStripTab, ITabStripTabs, IVirtualTabStripTab
	[
		object,
		uuid(3EA4757A-99A2-457f-8EF5-ECCFEBF893A7),
		dual,
		nonextensible,
		helpstring("ITabStrip interface"),
		pointer_default(unique)
	]
	interface ITabStrip : IDispatch
	{
		/// \brief <em>Specifies the control's active tab</em>
		///
		/// Retrieves or sets the control's active tab. The active tab is the tab whose content is currently
		/// displayed.
		///
		/// \remarks This is the control's default property.
		///
		/// \sa CaretTab, ITabStripTab::Active, MultiSelect, _ITabStripEvents::ActiveTabChanging,
		///     _ITabStripEvents::ActiveTabChanged
		[propget, id(DISPID_TABSTRIPCTL_ACTIVETAB), helpstring("Retrieves or sets the control's active tab. The active tab is the tab whose content is currently displayed."), nonbrowsable]
		HRESULT ActiveTab([out, retval] ITabStripTab** ppActiveTab);
		[propputref, id(DISPID_TABSTRIPCTL_ACTIVETAB), helpstring("Retrieves or sets the control's active tab. The active tab is the tab whose content is currently displayed."), nonbrowsable]
		HRESULT ActiveTab([in] ITabStripTab* pNewActiveTab);
		/// \brief <em>Specifies whether the control detects drag'n'drop operations</em>
		///
		/// Retrieves or sets whether drag'n'drop mode can be entered. If set to \c True, drag'n'drop mode
		/// can be entered by pressing the left or right mouse button over a tab and then moving the mouse
		/// with the button still pressed. If set to \c False, drag'n'drop mode is not available - this
		/// also means the \c TabBeginDrag and \c TabBeginRDrag events don't get fired.
		///
		/// \sa RegisterForOLEDragDrop, DragActivateTime, DragScrollTimeBase, SetInsertMarkPosition,
		///     _ITabStripEvents::TabBeginDrag, _ITabStripEvents::TabBeginRDrag
		[propget, id(DISPID_TABSTRIPCTL_ALLOWDRAGDROP), helpstring("Retrieves or sets whether drag'n'drop mode can be entered.")]
		HRESULT AllowDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_ALLOWDRAGDROP), helpstring("Retrieves or sets whether drag'n'drop mode can be entered.")]
		HRESULT AllowDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_TABSTRIPCTL_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TABSTRIPCTL_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TABSTRIPCTL_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TABSTRIPCTL_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_TABSTRIPCTL_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TABSTRIPCTL_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Specifies the control's caret tab</em>
		///
		/// Retrieves or sets the control's caret tab. The caret tab is the tab that has the keyboard focus.
		///
		/// \sa ActiveTab, ITabStripTab::Caret, MultiSelect, _ITabStripEvents::CaretChanged
		[propget, id(DISPID_TABSTRIPCTL_CARETTAB), helpstring("Retrieves or sets the control's caret tab. The caret tab is the tab that has the keyboard focus."), nonbrowsable]
		HRESULT CaretTab([out, retval] ITabStripTab** ppCaretTab);
		[propputref, id(DISPID_TABSTRIPCTL_CARETTAB), helpstring("Retrieves or sets the control's caret tab. The caret tab is the tab that has the keyboard focus."), nonbrowsable]
		HRESULT CaretTab([in] ITabStripTab* pNewCaretTab);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TABSTRIPCTL_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether each tab contains a close button</em>
		///
		/// Retrieves or sets whether close buttons are drawn for each tab. If set to \c True, close buttons
		/// are drawn; otherwise not.
		///
		/// \sa CloseableTabsMode
		[propget, id(DISPID_TABSTRIPCTL_CLOSEABLETABS), helpstring("Retrieves or sets whether close buttons are drawn for each tab.")]
		HRESULT CloseableTabs([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_CLOSEABLETABS), helpstring("Retrieves or sets whether close buttons are drawn for each tab.")]
		HRESULT CloseableTabs([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_TABSTRIPCTL_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Retrieves the height of the control's display area</em>
		///
		/// Retrieves the height of the control's display area in pixels. The display area is the area
		/// available for the tabs' content.
		///
		/// \remarks This property is read-only.
		///
		/// \sa TabHeight, ITabStripTab::Height, DisplayAreaLeft, DisplayAreaTop, DisplayAreaWidth,
		///     CalculateDisplayArea
		[propget, id(DISPID_TABSTRIPCTL_DISPLAYAREAHEIGHT), helpstring("Retrieves the height of the control's display area in pixels."), nonbrowsable]
		HRESULT DisplayAreaHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the left border of the control's display area</em>
		///
		/// Retrieves the distance between the control's left border and the display area's left border in
		/// pixels. The display area is the area available for the tabs' content.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ITabStripTab::Left, DisplayAreaHeight, DisplayAreaTop, DisplayAreaWidth,
		///     CalculateDisplayArea
		[propget, id(DISPID_TABSTRIPCTL_DISPLAYAREALEFT), helpstring("Retrieves the distance between the control's left border and the display area's left border in pixels."), nonbrowsable]
		HRESULT DisplayAreaLeft([out, retval] OLE_XPOS_PIXELS* pValue);
		/// \brief <em>Retrieves the upper border of the control's display area</em>
		///
		/// Retrieves the distance between the control's upper border and the display area's upper border in
		/// pixels. The display area is the area available for the tabs' content.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ITabStripTab::Top, DisplayAreaHeight, DisplayAreaLeft, DisplayAreaWidth,
		///     CalculateDisplayArea
		[propget, id(DISPID_TABSTRIPCTL_DISPLAYAREATOP), helpstring("Retrieves the distance between the control's upper border and the display area's upper border in pixels."), nonbrowsable]
		HRESULT DisplayAreaTop([out, retval] OLE_YPOS_PIXELS* pValue);
		/// \brief <em>Retrieves the width of the control's display area</em>
		///
		/// Retrieves the width of the control's display area in pixels. The display area is the area
		/// available for the tabs' content.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ITabStripTab::Width, DisplayAreaHeight, DisplayAreaLeft, DisplayAreaTop,
		///     CalculateDisplayArea
		[propget, id(DISPID_TABSTRIPCTL_DISPLAYAREAWIDTH), helpstring("Retrieves the width of the control's display area in pixels."), nonbrowsable]
		HRESULT DisplayAreaWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		// \brief <em>Controls redrawing of the control</em>
		//
		// Enables or disables automatic redrawing of the control. Disabling redraw while doing large
		// changes on the control may increase performance.
		// If set to \c False, the control will redraw itself automatically; otherwise not.
		//[propget, id(DISPID_TABSTRIPCTL_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		//HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		//[propput, id(DISPID_TABSTRIPCTL_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		//HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the speed of automatic tab activation during drag'n'drop</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be placed over a tab during a
		/// drag'n'drop operation before this tab will be activated automatically. If set to 0, auto-activation
		/// is disabled. If set to -1, the system's double-click time is used.
		///
		/// \sa AllowDragDrop, RegisterForOLEDragDrop, DragScrollTimeBase,
		///     _ITabStripEvents::DragMouseMove, _ITabStripEvents::OLEDragMouseMove
		[propget, id(DISPID_TABSTRIPCTL_DRAGACTIVATETIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over a tab during a drag'n'drop operation before this tab will be activated automatically.")]
		HRESULT DragActivateTime([out, retval] LONG* pValue);
		[propput, id(DISPID_TABSTRIPCTL_DRAGACTIVATETIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over a tab during a drag'n'drop operation before this tab will be activated automatically.")]
		HRESULT DragActivateTime([in] LONG newValue);
		/// \brief <em>Retrieves the tabs currently dragged</em>
		///
		/// Retrieves a collection object wrapping the tabs that are currently dragged. These are the
		/// same tabs that were passed to the \c BeginDrag or \c OLEDrag method.
		///
		/// \remarks This property is read-only.
		///
		/// \sa BeginDrag, OLEDrag, ITabStripTabContainer, Tabs
		[propget, id(DISPID_TABSTRIPCTL_DRAGGEDTABS), helpstring("Retrieves a collection object wrapping the tabs that are currently dragged."), nonbrowsable]
		HRESULT DraggedTabs([out, retval] ITabStripTabContainer** ppTabs);
		/// \brief <em>Controls the speed of automatic scrolling during drag'n'drop</em>
		///
		/// Retrieves or sets the period of time (in milliseconds) that is used as the time-base to
		/// calculate the velocity of auto-scrolling during a drag'n'drop operation. If set to 0,
		/// auto-scrolling is disabled. If set to -1, the system's double-click time, divided by 4, is
		/// used.
		///
		/// \sa AllowDragDrop, RegisterForOLEDragDrop, DragActivateTime, _ITabStripEvents::OLEDragMouseMove
		[propget, id(DISPID_TABSTRIPCTL_DRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT DragScrollTimeBase([out, retval] LONG* pValue);
		[propput, id(DISPID_TABSTRIPCTL_DRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT DragScrollTimeBase([in] LONG newValue);
		/// \brief <em>Specifies the tab that currently is the drop target</em>
		///
		/// Retrieves or sets the tab, that is the target of a drag'n'drop operation. Its background is
		/// drawn highlighted. If set to \c Nothing, no tab is a drop target.
		///
		/// \sa ITabStripTab::DropHilited, AllowDragDrop, RegisterForOLEDragDrop, CaretTab,
		///     _ITabStripEvents::OLEDragMouseMove
		[propget, id(DISPID_TABSTRIPCTL_DROPHILITEDTAB), helpstring("Retrieves or sets the tab, that is the target of a drag'n'drop operation."), nonbrowsable]
		HRESULT DropHilitedTab([out, retval] ITabStripTab** ppDropHilitedTab);
		[propputref, id(DISPID_TABSTRIPCTL_DROPHILITEDTAB), helpstring("Retrieves or sets the tab, that is the target of a drag'n'drop operation."), nonbrowsable]
		HRESULT DropHilitedTab([in] ITabStripTab* pNewDropHilitedTab);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_TABSTRIPCTL_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the tabs' fixed width</em>
		///
		/// Retrieves or sets the tabs' fixed width in pixels.
		///
		/// \sa UseFixedTabWidth, MinTabWidth, TabHeight, DisplayAreaWidth
		[propget, id(DISPID_TABSTRIPCTL_FIXEDTABWIDTH), helpstring("Retrieves or sets the tabs' fixed width in pixels.")]
		HRESULT FixedTabWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TABSTRIPCTL_FIXEDTABWIDTH), helpstring("Retrieves or sets the tabs' fixed width in pixels.")]
		HRESULT FixedTabWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies whether clicking a tab moves the keyboard focus to the control</em>
		///
		/// Retrieves or sets whether the control receives the keyboard focus if a tab is clicked. If set to
		/// \c True, the keyboard focus is set to the control; otherwise not.
		[propget, id(DISPID_TABSTRIPCTL_FOCUSONBUTTONDOWN), helpstring("Retrieves or sets whether the control receives the keyboard focus if a tab is clicked.")]
		HRESULT FocusOnButtonDown([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_FOCUSONBUTTONDOWN), helpstring("Retrieves or sets whether the control receives the keyboard focus if a tab is clicked.")]
		HRESULT FocusOnButtonDown([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the tabs' text.
		///
		/// \sa UseSystemFont, ITabStripTab::Text
		[propget, id(DISPID_TABSTRIPCTL_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_TABSTRIPCTL_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_TABSTRIPCTL_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Retrieves the imagelist containing the drag image</em>
		///
		/// Retrieves the handle to the imagelist containing the drag image that is used during a
		/// drag'n'drop operation to visualize the dragged tabs.
		///
		/// \sa ShowDragImage, BeginDrag, _ITabStripEvents::DragMouseMove
		[propget, id(DISPID_TABSTRIPCTL_HDRAGIMAGELIST), helpstring("Retrieves the handle to the imagelist containing the drag image that is used during a drag'n'drop operation to visualize the dragged tabs."), nonbrowsable]
		HRESULT hDragImageList([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the control's associated imagelist that is used for Aero drag images</em>
		///
		/// Retrieves or sets the handle to the imagelist containing the control's icons that are used when
		/// icons with a high resolution are required. Currently the only usage of this imagelist is the
		/// creation of Aero OLE drag images.\n
		/// If set to 0, the imagelist specified by the \c hImageList property is used.
		///
		/// \remarks The previously set image list does NOT get destroyed automatically.
		///
		/// \sa ITabStripTab::IconIndex, hImageList, SupportOLEDragImages, OLEDrag
		[propget, id(DISPID_TABSTRIPCTL_HHIGHRESIMAGELIST), helpstring("Retrieves or sets the handle of the control's imagelist that is used for Aero OLE drag images."), nonbrowsable]
		HRESULT hHighResImageList([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_TABSTRIPCTL_HHIGHRESIMAGELIST), helpstring("Retrieves or sets the handle of the control's imagelist that is used for Aero OLE drag images."), nonbrowsable]
		HRESULT hHighResImageList([in] OLE_HANDLE newValue);
		/// \brief <em>Specifies the control's associated imagelist</em>
		///
		/// Retrieves or sets the handle to the imagelist containing the tabs' icons. If set to 0, no icons are
		/// drawn.
		///
		/// \remarks The previously set image list does NOT get destroyed automatically.
		///
		/// \sa ITabStripTab::IconIndex, hHighResImageList
		[propget, id(DISPID_TABSTRIPCTL_HIMAGELIST), helpstring("Retrieves or sets the handle of the control's imagelist."), nonbrowsable]
		HRESULT hImageList([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_TABSTRIPCTL_HIMAGELIST), helpstring("Retrieves or sets the handle of the control's imagelist."), nonbrowsable]
		HRESULT hImageList([in] OLE_HANDLE newValue);
		/// \brief <em>Controls the tabs' appearance</em>
		///
		/// Retrieves or sets the amount of space (padding) to the left and right of each tab's icon and label
		/// in pixels.
		///
		/// \sa VerticalPadding, ITabStripTab::IconIndex, ITabStripTab::Text
		[propget, id(DISPID_TABSTRIPCTL_HORIZONTALPADDING), helpstring("Retrieves or sets the amount of space (padding) to the left and right of each tab's icon and label in pixels.")]
		HRESULT HorizontalPadding([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TABSTRIPCTL_HORIZONTALPADDING), helpstring("Retrieves or sets the amount of space (padding) to the left and right of each tab's icon and label in pixels.")]
		HRESULT HorizontalPadding([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the control's mouse-hover effects</em>
		///
		/// Retrieves or sets whether the tab underneath the mouse cursor becomes highlighted. If set to
		/// \c True, the tab becomes highlighted; otherwise not.
		///
		/// \remarks This property isn't supported for themed tabstrips.
		[propget, id(DISPID_TABSTRIPCTL_HOTTRACKING), helpstring("Retrieves or sets whether the tab underneath the mouse cursor becomes highlighted. This property isn't supported for themed tabstrips.")]
		HRESULT HotTracking([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_HOTTRACKING), helpstring("Retrieves or sets whether the tab underneath the mouse cursor becomes highlighted. This property isn't supported for themed tabstrips.")]
		HRESULT HotTracking([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's
		/// client area before the \c MouseHover event is fired. If set to -1, the system hover time is used.
		///
		/// \sa _ITabStripEvents::MouseHover
		[propget, id(DISPID_TABSTRIPCTL_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_TABSTRIPCTL_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWndArrowButtons, _ITabStripEvents::RecreatedControlWindow, _ITabStripEvents::DestroyedControlWindow
		[propget, id(DISPID_TABSTRIPCTL_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the contained up-down control's window handle</em>
		///
		/// Retrieves the window handle of the up-down control that is displayed to let the user scroll the
		/// tabs.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndToolTip
		[propget, id(DISPID_TABSTRIPCTL_HWNDARROWBUTTONS), helpstring("Retrieves the window handle of the up-down control that is displayed to let the user scroll the tabs."), nonbrowsable]
		HRESULT hWndArrowButtons([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the tooltip control's window handle</em>
		///
		/// Retrieves or sets the tooltip control's window handle.
		///
		/// \remarks The previously set tooltip window does NOT get destroyed automatically.
		///
		/// \sa hWndArrowButtons, ShowToolTips
		[propget, id(DISPID_TABSTRIPCTL_HWNDTOOLTIP), helpstring("Retrieves or sets the tooltip control's window handle."), nonbrowsable]
		HRESULT hWndToolTip([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_TABSTRIPCTL_HWNDTOOLTIP), helpstring("Retrieves or sets the tooltip control's window handle."), nonbrowsable]
		HRESULT hWndToolTip([in] OLE_HANDLE newValue);
		/// \brief <em>Specifies the color of the control's insertion mark</em>
		///
		/// Retrieves or sets the color that the control's insertion mark is drawn in.
		///
		/// \sa SetInsertMarkPosition
		[propget, id(DISPID_TABSTRIPCTL_INSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT InsertMarkColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TABSTRIPCTL_INSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT InsertMarkColor([in] OLE_COLOR newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TABSTRIPCTL_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies the tabs' minimum width</em>
		///
		/// Retrieves or sets the tabs' minimum width in pixels. If set to -1, the system's default tab width
		/// is used.
		///
		/// \sa FixedTabWidth, TabHeight, DisplayAreaWidth
		[propget, id(DISPID_TABSTRIPCTL_MINTABWIDTH), helpstring("Retrieves or sets the tabs' minimum width in pixels.")]
		HRESULT MinTabWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TABSTRIPCTL_MINTABWIDTH), helpstring("Retrieves or sets the tabs' minimum width in pixels.")]
		HRESULT MinTabWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_TABSTRIPCTL_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_TABSTRIPCTL_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_TABSTRIPCTL_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_TABSTRIPCTL_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Controls the arrangement of the control's tabs</em>
		///
		/// Retrieves or sets whether the tabs are displayed in multiple rows if they don't fit next to each
		/// other. If set to \c True, multiple rows are used; otherwise two arrow buttons are displayed that
		/// let the user scroll the tabs.
		///
		/// \remarks If this property is set to \c False while the \c ScrollToOpposite property is set to
		///          \c True, the \c ScrollToOpposite property will be changed to \c False.\n
		///          If this property is set to \c False while the \c TabPlacement property is set to \c tpLeft
		///          or \c tpRight, the \c TabPlacement property will be changed to \c tpTop.
		///
		/// \sa ScrollToOpposite, Style, TabPlacement, UseFixedTabWidth, RaggedTabRows, CountTabRows
		[propget, id(DISPID_TABSTRIPCTL_MULTIROW), helpstring("Retrieves or sets whether the tabs are displayed in multiple rows if they don't fit next to each other.")]
		HRESULT MultiRow([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_MULTIROW), helpstring("Retrieves or sets whether the tabs are displayed in multiple rows if they don't fit next to each other.")]
		HRESULT MultiRow([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether multiple tabs can be selected</em>
		///
		/// Retrieves or sets whether multiple tabs can be selected at the same time. If set to \c True,
		/// the user may select multiple tabs; otherwise not.
		///
		/// \remarks Multiselection won't work if the \c Style property is set to \c sTabs.
		///
		/// \sa Style, ActiveTab, CaretTab, ITabStripTab::Selected, ITabStripTabs::DeselectAll
		[propget, id(DISPID_TABSTRIPCTL_MULTISELECT), helpstring("Retrieves or sets whether multiple items can be selected at the same time. Multiselection won't work if the 'Style' property is set to 'sTabs'.")]
		HRESULT MultiSelect([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_MULTISELECT), helpstring("Retrieves or sets whether multiple items can be selected at the same time. Multiselection won't work if the 'Style' property is set to 'sTabs'.")]
		HRESULT MultiSelect([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the appearance of the OLE drag images generated by the control</em>
		///
		/// Retrieves or sets the appearance of the OLE drag images generated by the control. Any of the values
		/// defined by the \c OLEDragImageStyleConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, OLEDrag, OLEDragImageStyleConstants
		[propget, id(DISPID_TABSTRIPCTL_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([out, retval] OLEDragImageStyleConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([in] OLEDragImageStyleConstants newValue);
		/// \brief <em>Specifies whether the tabs are drawn by the application instead of the control</em>
		///
		/// Retrieves or sets whether your application draws the tabs itself. If set to \c True, the control
		/// will fire the \c OwnerDrawTab event each time a tab must be drawn. If set to \c False, the control
		/// will draw the tabs itself.
		///
		/// \sa _ITabStripEvents::OwnerDrawTab
		[propget, id(DISPID_TABSTRIPCTL_OWNERDRAWN), helpstring("Retrieves or sets whether your application draws the tabs itself.")]
		HRESULT OwnerDrawn([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_OWNERDRAWN), helpstring("Retrieves or sets whether your application draws the tabs itself.")]
		HRESULT OwnerDrawn([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the event is fired; otherwise not.
		///
		/// \sa _ITabStripEvents::ContextMenu
		[propget, id(DISPID_TABSTRIPCTL_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_TABSTRIPCTL_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether tabs are stretched</em>
		///
		/// Retrieves or sets whether tabs are stretched so that each tab row in a multi-row control fills up
		/// the control's whole width. If set to \c False, the tabs are stretched; otherwise not.
		///
		/// \sa MultiRow, UseFixedTabWidth
		[propget, id(DISPID_TABSTRIPCTL_RAGGEDTABROWS), helpstring("Retrieves or sets whether tabs are stretched so that each tab row in a multi-row control fills up the control's whole width.")]
		HRESULT RaggedTabRows([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_RAGGEDTABROWS), helpstring("Retrieves or sets whether tabs are stretched so that each tab row in a multi-row control fills up the control's whole width.")]
		HRESULT RaggedTabRows([in] VARIANT_BOOL newValue);
		// \brief <em>Specifies whether \c WM_CONTEXTMENU messages are reflected back to the child windows they come from</em>
		//
		// Retrieves or sets whether whether \c WM_CONTEXTMENU messages are reflected back to the child
		// windows they come from.\n
		// Usually controls send the \c WM_CONTEXTMENU message to the parent window, so to trap this message
		// the parent window of the control must be subclassed. This design is great for C++ applications,
		// because in a C++ app, you watch the main window's messages anyway, but usually don't watch a single
		// control's messages. In a VB6 app, things are different. You don't watch the main window's messages
		// by default, but the controls watch their own messages. So in a VB6 app it would be better if the
		// controls would send \c WM_CONTEXTMENU to themselves and not to the parent window.\n
		// TimoSoft controls have a \c ContextMenu event, but this event won't be raised by default, because
		// the \c WM_CONTEXTMENU goes to the wrong window. That's the reason why all samples provided with
		// those controls subclass the Form and reflect \c WM_CONTEXTMENU back to the control. \c TabStrip can
		// make things a bit easier and do the message reflection for any child controls.\n
		// If this property is set to \c True, the \c WM_CONTEXTMENU message gets reflected; otherwise not.
		//
		// \sa _ITabStripEvents::ContextMenu
		//[propget, id(DISPID_TABSTRIPCTL_REFLECTCONTEXTMENUMESSAGES), helpstring("Retrieves or sets whether 'WM_CONTEXTMENU' messages are reflected back to the child windows they come from.")]
		//HRESULT ReflectContextMenuMessages([out, retval] VARIANT_BOOL* pValue);
		//[propput, id(DISPID_TABSTRIPCTL_REFLECTCONTEXTMENUMESSAGES), helpstring("Retrieves or sets whether 'WM_CONTEXTMENU' messages are reflected back to the child windows they come from.")]
		//HRESULT ReflectContextMenuMessages([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. Any of the
		/// values defined by the \c RegisterForOLEDragDropConstants enumeration is valid.
		///
		/// \sa AllowDragDrop, SupportOLEDragImages, _ITabStripEvents::OLEDragEnter,
		///     RegisterForOLEDragDropConstants
		[propget, id(DISPID_TABSTRIPCTL_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] RegisterForOLEDragDropConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] RegisterForOLEDragDropConstants newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \attention Setting or clearing the \c rtlLayout flag at runtime leads to drawing glitches.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_TABSTRIPCTL_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Setting or clearing the 'rtlLayout' flag at runtime leads to drawing glitches.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Setting or clearing the 'rtlLayout' flag at runtime leads to drawing glitches.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Controls the arrangement of the control's tabs</em>
		///
		/// Retrieves or sets whether unneeded tabs scroll to the opposite side of the control when a tab is
		/// selected. If set to \c True, tabs scroll to the opposite side; otherwise not.
		///
		/// \remarks If this property is set to \c True while the \c MultiRow property is set to \c False,
		///          the \c MultiRow property will be changed to \c True.\n
		///          If this property is set to \c True while the \c Style property is set to \c sButtons
		///          or \c sFlatButtons, the \c Style property will be changed to \c sTabs.
		///
		/// \attention This property can't be changed at runtime.
		///
		/// \sa MultiRow, Style, TabPlacement
		[propget, id(DISPID_TABSTRIPCTL_SCROLLTOOPPOSITE), helpstring("Retrieves or sets whether unneeded tabs scroll to the opposite side of the control when a tab is selected. This property can't be changed at runtime.")]
		HRESULT ScrollToOpposite([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_SCROLLTOOPPOSITE), helpstring("Retrieves or sets whether unneeded tabs scroll to the opposite side of the control when a tab is selected. This property can't be changed at runtime.")]
		HRESULT ScrollToOpposite([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how tabs are visually separated</em>
		///
		/// Retrieves or sets whether the control draws separator lines between the tabs if the \c Style
		/// property is set to \c sFlatButtons. If set to \c True, separators are drawn; otherwise not.
		///
		/// \sa Style
		[propget, id(DISPID_TABSTRIPCTL_SHOWBUTTONSEPARATORS), helpstring("Retrieves or sets whether the control draws separator lines between the tabs if the 'Style' property is set to 'sFlatButtons'.")]
		HRESULT ShowButtonSeparators([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_SHOWBUTTONSEPARATORS), helpstring("Retrieves or sets whether the control draws separator lines between the tabs if the 'Style' property is set to 'sFlatButtons'.")]
		HRESULT ShowButtonSeparators([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the visibility of the control's drag image</em>
		///
		/// Retrieves or sets whether the drag image is currently visible or hidden. If set to \c True, it
		/// is visible; otherwise it is hidden.
		///
		/// \sa hDragImageList, SupportOLEDragImages, _ITabStripEvents::DragMouseMove
		[propget, id(DISPID_TABSTRIPCTL_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control displays any tooltips</em>
		///
		/// Enables or disables tooltips. If set to \c True, the control displays tab-specific tooltips;
		/// otherwise not.
		///
		/// \attention This property can't be changed at runtime.
		///
		/// \sa hWndToolTip, _ITabStripEvents::TabGetInfoTipText
		[propget, id(DISPID_TABSTRIPCTL_SHOWTOOLTIPS), helpstring("Enables or disables tooltips. This property can't be changed at runtime.")]
		HRESULT ShowToolTips([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_SHOWTOOLTIPS), helpstring("Enables or disables tooltips. This property can't be changed at runtime.")]
		HRESULT ShowToolTips([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the general appearance of the control's tabs</em>
		///
		/// Retrieves or sets the tabs' style. Any of the values defined by the \c StyleConstants enumeration
		/// is valid.
		///
		/// \remarks If this property is set to \c sButtons or \c sFlatButtons while the \c ScrollToOpposite
		///          property is set to \c True, the \c ScrollToOpposite property will be changed to
		///          \c False.\n
		///          Changing this property at runtime leads to drawing glitches if the control is themed.
		///
		/// \sa Appearance, BorderStyle, MultiRow, ScrollToOpposite, TabPlacement, StyleConstants
		[propget, id(DISPID_TABSTRIPCTL_STYLE), helpstring("Retrieves or sets the tabs' style. Changing this property at runtime leads to drawing glitches if the control is themed.")]
		HRESULT Style([out, retval] StyleConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_STYLE), helpstring("Retrieves or sets the tabs' style. Changing this property at runtime leads to drawing glitches if the control is themed.")]
		HRESULT Style([in] StyleConstants newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, hHighResImageList, ShowDragImage, OLEDragImageStyle, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_TABSTRIPCTL_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies which parts of a tab are handled as such</em>
		///
		/// Retrieves or sets the parts of a tab that get handled as such if firing any kind of mouse
		/// event. Any combination of the values defined by the \c TabBoundingBoxDefinitionConstants
		/// enumeration is valid. E. g. if set to \c tbbdTabIcon, the \c tsTab parameter of the \c MouseMove
		/// event will identify the tab only if the mouse cursor is located over the tab's icon; otherwise
		/// (e. g. if the cursor is located over the tab's text) it will be \c Nothing.
		///
		/// \sa HitTest, TabBoundingBoxDefinitionConstants
		[propget, id(DISPID_TABSTRIPCTL_TABBOUNDINGBOXDEFINITION), helpstring("Retrieves or sets the parts of a tab that get handled as such if firing any kind of mouse event."), nonbrowsable]
		HRESULT TabBoundingBoxDefinition([out, retval] TabBoundingBoxDefinitionConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_TABBOUNDINGBOXDEFINITION), helpstring("Retrieves or sets the parts of a tab that get handled as such if firing any kind of mouse event."), nonbrowsable]
		HRESULT TabBoundingBoxDefinition([in] TabBoundingBoxDefinitionConstants newValue);
		/// \brief <em>Controls the alignment of the tabs' captions</em>
		///
		/// Retrieves or sets the alignment of the tabs' captions. Any of the values defined by the
		/// \c TabCaptionAlignmentConstants enumeration is valid.
		///
		/// \remarks This property is ignored if the \c UseFixedTabWidth property is set to \c False.
		///
		/// \sa UseFixedTabWidth, ITabStripTab::IconIndex, TabCaptionAlignmentConstants
		[propget, id(DISPID_TABSTRIPCTL_TABCAPTIONALIGNMENT), helpstring("Retrieves or sets the alignment of the tabs' captions. This property is ignored if the 'UseFixedTabWidth' property is set to 'False'.")]
		HRESULT TabCaptionAlignment([out, retval] TabCaptionAlignmentConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_TABCAPTIONALIGNMENT), helpstring("Retrieves or sets the alignment of the tabs' captions. This property is ignored if the 'UseFixedTabWidth' property is set to 'False'.")]
		HRESULT TabCaptionAlignment([in] TabCaptionAlignmentConstants newValue);
		/// \brief <em>Specifies all tabs' height</em>
		///
		/// Retrieves or sets the tabs' height in pixels.
		///
		/// \sa FixedTabWidth, MinTabWidth, DisplayAreaHeight
		[propget, id(DISPID_TABSTRIPCTL_TABHEIGHT), helpstring("Retrieves or sets the tabs' height in pixels.")]
		HRESULT TabHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_TABSTRIPCTL_TABHEIGHT), helpstring("Retrieves or sets the tabs' height in pixels.")]
		HRESULT TabHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the arrangement of the control's tabs</em>
		///
		/// Retrieves or sets the side of the control at which the tabs are displayed. Any of the values
		/// defined by the \c TabPlacementConstants enumeration is valid.
		///
		/// \remarks If this property is set to \c tpLeft or \c tpRight while the \c MultiRow property is set
		///          to \c False, the \c MultiRow property will be changed to \c True.
		///
		/// \attention This property can't be changed from or to \c tpLeft or \c tpRight at runtime.
		///
		/// \sa MultiRow, Style, TabPlacementConstants
		[propget, id(DISPID_TABSTRIPCTL_TABPLACEMENT), helpstring("Retrieves or sets the side of the control at which the tabs are displayed. This property can't be changed from or to 'tpLeft' or 'tpRight' at runtime.")]
		HRESULT TabPlacement([out, retval] TabPlacementConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_TABPLACEMENT), helpstring("Retrieves or sets the side of the control at which the tabs are displayed. This property can't be changed from or to 'tpLeft' or 'tpRight' at runtime.")]
		HRESULT TabPlacement([in] TabPlacementConstants newValue);
		/// \brief <em>Retrieves the control's tabs</em>
		///
		/// Retrieves a collection object wrapping the tabstrip tabs.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ITabStripTabs
		[propget, id(DISPID_TABSTRIPCTL_TABS), helpstring("Retrieves a collection object wrapping the control's tabs."), nonbrowsable]
		HRESULT Tabs([out, retval] ITabStripTabs** ppTabs);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_TABSTRIPCTL_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether all of the control's tabs are the same width</em>
		///
		/// Retrieves or sets whether all tabs are the same width. If set to \c True, the tabs are the same
		/// width; otherwise not.
		///
		/// \sa FixedTabWidth, RaggedTabRows, TabCaptionAlignment
		[propget, id(DISPID_TABSTRIPCTL_USEFIXEDTABWIDTH), helpstring("Retrieves or sets whether all tabs are the same width.")]
		HRESULT UseFixedTabWidth([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_USEFIXEDTABWIDTH), helpstring("Retrieves or sets whether all tabs are the same width.")]
		HRESULT UseFixedTabWidth([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_TABSTRIPCTL_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TABSTRIPCTL_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_TABSTRIPCTL_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);
		/// \brief <em>Controls the tabs' appearance</em>
		///
		/// Retrieves or sets the amount of space (padding) above and below each tab's icon and label in
		/// pixels.
		///
		/// \sa HorizontalPadding, ITabStripTab::IconIndex, ITabStripTab::Text
		[propget, id(DISPID_TABSTRIPCTL_VERTICALPADDING), helpstring("Retrieves or sets the amount of space (padding) above and below each tab's icon and label in pixels.")]
		HRESULT VerticalPadding([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_TABSTRIPCTL_VERTICALPADDING), helpstring("Retrieves or sets the amount of space (padding) above and below each tab's icon and label in pixels.")]
		HRESULT VerticalPadding([in] OLE_YSIZE_PIXELS newValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_TABSTRIPCTL_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Enters drag'n'drop mode</em>
		///
		/// \param[in] draggedTabs A collection object containing the tabs to drag.
		/// \param[in] hDragImageList The imagelist containing the drag image that shall be used to
		///            visualize the drag'n'drop operation. If -1, the control creates the drag image
		///            itself; if \c 0, no drag image is used.
		/// \param[in,out] xHotSpot The x-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
		///                0, this parameter is ignored. This parameter will be changed to the value that
		///                finally was used by the method.
		/// \param[in,out] yHotSpot The y-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
		///                0, this parameter is ignored. This parameter will be changed to the value that
		///                finally was used by the method.
		///
		/// \sa OLEDrag, DraggedTabs, EndDrag, hDragImageList, _ITabStripEvents::TabBeginDrag,
		///     _ITabStripEvents::TabBeginRDrag, ITabStripTab::CreateDragImage,
		///     ITabStripTabContainer::CreateDragImage
		[id(DISPID_TABSTRIPCTL_BEGINDRAG), helpstring("Enters drag'n'drop mode.")]
		HRESULT BeginDrag([in] ITabStripTabContainer* draggedTabs, [in, defaultvalue(0)] OLE_HANDLE hDragImageList, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xHotSpot, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yHotSpot);
		/// \brief <em>Calculates a display area based on a window rectangle</em>
		///
		/// Calculates the display area, that a tabstrip control with the specified window rectangle would
		/// have.
		///
		/// \param[in] windowRectangle The window rectangle (in pixels) for which the display area shall be
		///            calculated.
		/// \param[in,out] displayArea The calculated display area rectangle (in pixels).
		///
		/// \sa CalculateWindowRectangle, DisplayAreaHeight, DisplayAreaLeft, DisplayAreaTop, DisplayAreaWidth,
		///     RECTANGLE
		[id(DISPID_TABSTRIPCTL_CALCULATEDISPLAYAREA), helpstring("Calculates the display area, that a tabstrip control with the specified window rectangle would have.")]
		HRESULT CalculateDisplayArea([in, out] RECTANGLE* windowRectangle, [in, out] RECTANGLE* displayArea);
		/// \brief <em>Calculates a window rectangle based on a display area</em>
		///
		/// Calculates the window rectangle, that a tabstrip control with the specified display area would
		/// have.
		///
		/// \param[in] displayArea The display area rectangle (in pixels) for which the window rectangle shall
		///            be calculated.
		/// \param[in,out] windowRectangle The calculated window rectangle (in pixels).
		///
		/// \sa CalculateDisplayArea, DisplayAreaHeight, DisplayAreaLeft, DisplayAreaTop, DisplayAreaWidth,
		///     RECTANGLE
		[id(DISPID_TABSTRIPCTL_CALCULATEWINDOWRECTANGLE), helpstring("Calculates the window rectangle, that a tabstrip control with the specified display area would have.")]
		HRESULT CalculateWindowRectangle([in, out] RECTANGLE* displayArea, [in, out] RECTANGLE* windowRectangle);
		/// \brief <em>Retrieves the current number of tab rows in the control</em>
		///
		/// \return The current number of tab rows.
		///
		/// \sa MultiRow
		[id(DISPID_TABSTRIPCTL_COUNTTABROWS), helpstring("Retrieves the current number of tab rows in the control.")]
		HRESULT CountTabRows([out, retval] LONG* pValue);
		/// \brief <em>Creates a new \c TabStripTabContainer object</em>
		///
		/// Retrieves a new \c TabStripTabContainer object and fills it with the specified tabs.
		///
		/// \param[in] Tabs The tab(s) to add to the collection. May be either \c Empty, a tab ID, a
		///            \c TabStripTab object or a \c TabStripTabs collection.
		///
		/// \return The created \c TabStripTabContainer object.
		///
		/// \sa ITabStripTabContainer::Clone, ITabStripTabContainer::Add
		[id(DISPID_TABSTRIPCTL_CREATETABCONTAINER), helpstring("Retrieves a new 'TabStripTabContainer' object and fills it with 'Tabs'.")]
		HRESULT CreateTabContainer([in, optional] VARIANT Tabs, [out, retval] ITabStripTabContainer** ppContainer);
		/// \brief <em>Exits drag'n'drop mode</em>
		///
		/// \param[in] abort If \c True, the drag'n'drop operation will be handled as aborted; otherwise
		///            it will be handled as a drop.
		///
		/// \sa DraggedTabs, BeginDrag, _ITabStripEvents::AbortedDrag, _ITabStripEvents::Drop
		[id(DISPID_TABSTRIPCTL_ENDDRAG), helpstring("Exits drag'n'drop mode.")]
		HRESULT EndDrag([in] VARIANT_BOOL abort);
		/// \brief <em>Proposes a position for the control's insertion mark</em>
		///
		/// Retrieves the insertion mark position that is closest to the specified point.
		///
		/// \param[in] x The x-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the control's upper-left corner.
		/// \param[out] relativePosition The insertion mark's position relative to the specified tab. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] tsTab The tab at which the insertion mark should be displayed.
		///
		/// \sa SetInsertMarkPosition, GetInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_TABSTRIPCTL_GETCLOSESTINSERTMARKPOSITION), helpstring("Retrieves the insertion mark position that is closest to the specified point.")]
		HRESULT GetClosestInsertMarkPosition([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] InsertMarkPositionConstants* relativePosition, [in, out] ITabStripTab** tsTab);
		/// \brief <em>Retrieves the position of the control's insertion mark</em>
		///
		/// \param[out] relativePosition The insertion mark's position relative to the specified tab. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] tsTab The tab at which the insertion mark is displayed.
		///
		/// \sa SetInsertMarkPosition, GetClosestInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_TABSTRIPCTL_GETINSERTMARKPOSITION), helpstring("Retrieves the position of the control's insertion mark.")]
		HRESULT GetInsertMarkPosition([in, out] InsertMarkPositionConstants* relativePosition, [in, out] ITabStripTab** tsTab);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in,out] hitTestDetails Receives a value specifying the exact part of the control the
		///                specified point lies in. Any of the values defined by the \c HitTestConstants
		///                enumeration is valid.
		///
		/// \return The tab that the specified point belongs to. \c Nothing, if no tab was "hit".
		///
		/// \sa TabBoundingBoxDefinition, HitTestConstants
		[id(DISPID_TABSTRIPCTL_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] ITabStripTab** ppHitTab);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_TABSTRIPCTL_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Enters OLE drag'n'drop mode</em>
		///
		/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
		///            drag'n'drop. If not specified, the control's own implementation is used.
		/// \param[in] supportedEffects A bit field defining all drop effects you want to support. Any
		///            combination of the values defined by the \c OLEDropEffectConstants enumeration
		///            (except \c odeScroll) is valid.
		/// \param[in] hWndToAskForDragImage The handle of the window, that will receive the
		///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the control
		///            creates the drag image itself. If \c SupportOLEDragImages is set to \c False, no
		///            drag image is used.
		/// \param[in] draggedTabs A collection object containing the tabs to drag. This parameter is
		///            used to generate the drag image, if \c hWndToAskForDragImage is set to -1.
		/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
		///            If set to 0 or 1, no item count label is displayed. If set to -1, the number of tabs
		///            contained in the \c draggedTabs collection is displayed in the item count label. If
		///            set to any value larger than 1, this value is displayed in the item count label.
		///
		/// \return The performed drop effect. Any of the values defined by the \c OLEDropEffectConstants
		///         enumeration (except \c odeScroll) is valid.
		///
		/// \sa BeginDrag, _ITabStripEvents::TabBeginDrag, _ITabStripEvents::TabBeginRDrag,
		///     _ITabStripEvents::OLEStartDrag, _ITabStripEvents::OLEGiveFeedback,
		///     _ITabStripEvents::OLEQueryContinueDrag, SupportOLEDragImages, OLEDragImageStyle,
		///     OLEDropEffectConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
		[id(DISPID_TABSTRIPCTL_OLEDRAG), helpstring("Enters OLE drag'n'drop mode.")]
		HRESULT OLEDrag([in, defaultvalue(NULL)] LONG* pDataObject, [in, defaultvalue(odeCopyOrMove)] OLEDropEffectConstants supportedEffects, [in, defaultvalue(-1)] OLE_HANDLE hWndToAskForDragImage, [in, defaultvalue(NULL)] ITabStripTabContainer* draggedTabs, [in, defaultvalue(-1)] LONG itemCountToDisplay, [out, retval] OLEDropEffectConstants* pPerformedEffects);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_TABSTRIPCTL_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_TABSTRIPCTL_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Sets the position of the control's insertion mark</em>
		///
		/// \param[in] relativePosition The insertion mark's position relative to the specified tab. Any
		///            of the values defined by the \c InsertMarkPositionConstants enumeration is valid.
		/// \param[in] tsTab The tab at which to display the insertion mark. If set to \c Nothing, the
		///            insertion mark is removed.
		///
		/// \sa GetInsertMarkPosition, GetClosestInsertMarkPosition, InsertMarkColor, AllowDragDrop,
		///     RegisterForOLEDragDrop, InsertMarkPositionConstants
		[id(DISPID_TABSTRIPCTL_SETINSERTMARKPOSITION), helpstring("Sets the position of the control's insertion mark.")]
		HRESULT SetInsertMarkPosition([in] InsertMarkPositionConstants relativePosition, [in] ITabStripTab* tsTab);

		/// \brief <em>Specifies which tabs are drawn with close buttons</em>
		///
		/// Retrieves or sets which tabs are drawn with close buttons. Any of the values defined by the
		/// \c CloseableTabsModeConstants enumeration is valid.
		///
		/// \sa CloseableTabs, CloseableTabsModeConstants
		[propget, id(DISPID_TABSTRIPCTL_CLOSEABLETABSMODE), helpstring("Retrieves or sets which tabs are drawn with close buttons.")]
		HRESULT CloseableTabsMode([out, retval] CloseableTabsModeConstants* pValue);
		[propput, id(DISPID_TABSTRIPCTL_CLOSEABLETABSMODE), helpstring("Retrieves or sets which tabs are drawn with close buttons.")]
		HRESULT CloseableTabsMode([in] CloseableTabsModeConstants newValue);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _ITabStripEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_TABSTRIPCTL_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _ITabStripEvents
	/// \brief <em>The \c TabStrip class' events interface</em>
	///
	/// This interface defines all events the \c TabStrip class may raise.
	///
	/// \sa ITabStrip
	[
		uuid(A03DF68E-668A-43ca-8D9F-B168051B31AF),
		helpstring("ITabStrip-event-interface")
	]
	dispinterface _ITabStripEvents
	{
		properties:
		methods:
			/// \brief <em>The active tab was changed</em>
			///
			/// Will be fired after another tab became the active tab. The active tab is the tab whose content is
			/// currently displayed.
			///
			/// \param[in] previousActiveTab The previous active tab.
			/// \param[in] newActiveTab The new active tab.
			///
			/// \remarks This is the control's default event.
			///
			/// \sa ActiveTabChanging, ITabStripTab::Active, ITabStrip::ActiveTab, CaretChanged
			[id(DISPID_TABSTRIPCTLE_ACTIVETABCHANGED), helpstring("Will be fired after another tab became the active tab. The active tab is the tab whose content is currently displayed.")]
			void ActiveTabChanged(ITabStripTab* previousActiveTab, ITabStripTab* newActiveTab);
			/// \brief <em>A drag'n'drop operation was aborted</em>
			///
			/// Will be fired if a drag'n'drop operation was aborted.
			///
			/// \sa Drop, ITabStrip::EndDrag
			[id(DISPID_TABSTRIPCTLE_ABORTEDDRAG), helpstring("Will be fired if a drag'n'drop operation was aborted.")]
			void AbortedDrag(void);
			/// \brief <em>The active tab is about to change</em>
			///
			/// Will be fired before another tab becomes the active tab. The active tab is the tab whose content
			/// is currently displayed.
			///
			/// \param[in] previousActiveTab The previous active tab.
			/// \param[in,out] cancelChange If set to \c True, the active tab change is aborted, i. e. the
			///                current active tab remains the active tab. In this case the \c ActiveTabChanged
			///                event isn't fired. If set to \c False, the active tab change is completed.
			///
			/// \sa ActiveTabChanged, ITabStripTab::Active, ITabStrip::ActiveTab, CaretChanged
			[id(DISPID_TABSTRIPCTLE_ACTIVETABCHANGING), helpstring("Will be fired before another tab becomes the active tab. The active tab is the tab whose content is currently displayed.")]
			void ActiveTabChanging(ITabStripTab* previousActiveTab, VARIANT_BOOL* cancelChange);
			/// \brief <em>The caret was changed</em>
			///
			/// Will be fired after another tab became the caret tab. The caret tab is the tab that has the
			/// keyboard focus.
			///
			/// \param[in] previousCaretTab The previous caret tab.
			/// \param[in] newCaretTab The new caret tab.
			///
			/// \remarks Requires comctl32.dll version 5.80 or higher.
			///
			/// \sa ITabStripTab::Caret, ITabStrip::CaretTab, ActiveTabChanged
			[id(DISPID_TABSTRIPCTLE_CARETCHANGED), helpstring("Will be fired after another tab became the caret tab. The caret tab is the tab that has the keyboard focus. Requires comctl32.dll version 5.80 or higher.")]
			void CaretChanged(ITabStripTab* previousCaretTab, ITabStripTab* newCaretTab);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] tsTab The tab that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, HitTestConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] tsTab The tab the context menu refers to. Will be \c Nothing if the context
			///            menu should be displayed for the whole control instead of only for a single tab.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the menu's proposed position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa RClick, HitTestConstants
			[id(DISPID_TABSTRIPCTLE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] tsTab The tab that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, HitTestConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, ITabStrip::hWnd
			[id(DISPID_TABSTRIPCTLE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area during a
			/// drag'n'drop operation.
			///
			/// \param[in,out] dropTarget The tab that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another tab.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoActivateTab If set to \c True, the tab specified by \c dropTarget will be
			///                auto-activated; otherwise not. See the following <strong>remarks</strong> section
			///                for details.
			/// \param[in,out] autoScrollVelocity The speed multiplier for auto-scrolling. If set to 0,
			///                auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls to the left or top (depending on the setting of the \c TabPlacement
			///                property); if set to a value greater than 0, the control auto-scrolls to the right
			///                or bottom. The higher/lower the value is, the faster the control scrolls.\n
			///                This value is ignored, if the \c RegisterForOLEDragDrop property is set to a value
			///                other than \c rfoddAdvancedDragDrop.
			///
			/// \remarks Auto-activation is timered, i. e. the timer is started after this event, if the
			///          \c dropTarget parameter specifies another tab than the last time this event was
			///          fired. Setting the \c autoActivateTab parameter to \c False cancels the timer. If
			///          it isn't canceled, the tab is activated when the timer expires.
			///
			/// \sa MouseMove, OLEDragMouseMove, ITabStrip::DragActivateTime, ITabStrip::DragScrollTimeBase,
			///     ITabStrip::DropHilitedTab, ITabStrip::TabPlacement, ITabStrip::SetInsertMarkPosition,
			///     ITabStrip::BeginDrag, HitTestConstants
			[id(DISPID_TABSTRIPCTLE_DRAGMOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area during a drag'n'drop operation.")]
			void DragMouseMove(ITabStripTab** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoActivateTab, LONG* autoScrollVelocity);
			/// \brief <em>A drag'n'drop operation ended successful</em>
			///
			/// Will be fired if a drag'n'drop operation ended successful.
			///
			/// \param[in] dropTarget The tab that is the nearest one from the mouse cursor's position. If
			///            the mouse cursor's position lies outside the control's client area, this parameter
			///            is \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa AbortedDrag, ITabStrip::EndDrag, HitTestConstants
			[id(DISPID_TABSTRIPCTLE_DROP), helpstring("Will be fired if a drag'n'drop operation ended successful.")]
			void Drop(ITabStripTab* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>Any data associated with a tab should be freed</em>
			///
			/// Will be fired if any data associated with the specified tab should be freed.
			///
			/// \param[in] tsTab The tab for which to free the data. If \c Nothing, all tabs' associated data
			///            shall be removed.
			///
			/// \remarks On program termination the application probably won't receive this event anymore,
			///          because Visual Basic shuts down the event receiver too early. So if you use this
			///          event to free any data, you should also add an event handler for \c Form_Unload (or
			///          similar) in which you iterate all tabs freeing their associated data.\n
			///          This event may be disabled.
			///
			/// \sa RemovingTab, RemovedTab, ITabStripTab::TabData, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_FREETABDATA), helpstring("Will be fired if any data associated with the specified tab should be freed. This event may be disabled.")]
			void FreeTabData(ITabStripTab* tsTab);
			/// \brief <em>A tab was inserted</em>
			///
			/// Will be fired after a new tab was inserted.
			///
			/// \param[in] tsTab The tab that was inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertingTab, RemovedTab, ITabStripTab, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_INSERTEDTAB), helpstring("Will be fired after a new tab was inserted. This event may be disabled.")]
			void InsertedTab(ITabStripTab* tsTab);
			/// \brief <em>A tab is about to be inserted</em>
			///
			/// Will be fired before a new tab is inserted.
			///
			/// \param[in] tsTab The tab that is about to be inserted.
			/// \param[in,out] cancelInsertion If set to \c True, insertion is aborted, i. e. the tab isn't
			///                inserted. If set to \c False, the tab is inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertedTab, RemovingTab, IVirtualTabStripTab, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_INSERTINGTAB), helpstring("Will be fired before a new tab is inserted. This event may be disabled.")]
			void InsertingTab(IVirtualTabStripTab* tsTab, VARIANT_BOOL* cancelInsertion);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] tsTab The tab that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, HitTestConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] tsTab The tab that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, HitTestConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] tsTab The tab that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] tsTab The tab that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, TabMouseEnter, MouseHover, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c ITabStrip::HoverTime property.
			///
			/// \param[in] tsTab The tab that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, ITabStrip::HoverTime, HitTestConstants,
			///     ExtendedMouseButtonConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] tsTab The tab that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, TabMouseLeave, MouseHover, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] tsTab The tab that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, HitTestConstants,
			///     ExtendedMouseButtonConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] tsTab The tab that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>An OLE drag'n'drop operation was completed</em>
			///
			/// Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.
			///
			/// \param[in] data The object that holds the dragged data. The drop target may have added data to
			///            it.
			/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
			///            defined by the \c OLEDropEffectConstants enumeration is valid.
			///
			/// \sa ITabStrip::OLEDrag, OLEStartDrag, IOLEDataObject::GetData
			[id(DISPID_TABSTRIPCTLE_OLECOMPLETEDRAG), helpstring("Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.")]
			void OLECompleteDrag(IOLEDataObject* data, OLEDropEffectConstants performedEffect);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] dropTarget The tab that is the nearest one from the mouse cursor's position.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, ITabStrip::RegisterForOLEDragDrop,
			///     ITabStrip::FinishOLEDragDrop, OLEDropEffectConstants, ITabStrip::DropHilitedTab,
			///     ITabStrip::SetInsertMarkPosition, HitTestConstants
			[id(DISPID_TABSTRIPCTLE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, ITabStripTab* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The tab that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another tab.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoActivateTab If set to \c True, the tab specified by \c dropTarget will be
			///                auto-activated; otherwise not. See the following <strong>remarks</strong> section
			///                for details.
			/// \param[in,out] autoScrollVelocity The speed multiplier for auto-scrolling. If set to 0,
			///                auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls to the left or top (depending on the setting of the \c TabPlacement
			///                property); if set to a value greater than 0, the control auto-scrolls to the right
			///                or bottom. The higher/lower the value is, the faster the control scrolls.\n
			///                This value is ignored, if the \c RegisterForOLEDragDrop property is set to a value
			///                other than \c rfoddAdvancedDragDrop.
			///
			/// \remarks Auto-activation is timered, i. e. the timer is started after this event, if the
			///          \c dropTarget parameter specifies another tab than the last time this event was
			///          fired. Setting the \c autoActivateTab parameter to \c False cancels the timer. If
			///          it isn't canceled, the tab is activated when the timer expires.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, ITabStrip::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, ITabStrip::DragActivateTime, ITabStrip::DragScrollTimeBase,
			///     ITabStrip::DropHilitedTab, ITabStrip::TabPlacement, ITabStrip::SetInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_TABSTRIPCTLE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, ITabStripTab** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoActivateTab, LONG* autoScrollVelocity);
			/// \brief <em>The user has dragged the data into a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop
			/// target window.
			///
			/// \param[in] hWndPotentialTarget The potential drop target window's handle.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragLeavePotentialTarget, ITabStrip::OLEDrag
			[id(DISPID_TABSTRIPCTLE_OLEDRAGENTERPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The tab that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, ITabStrip::RegisterForOLEDragDrop,
			///     ITabStrip::DropHilitedTab, ITabStrip::SetInsertMarkPosition, HitTestConstants
			[id(DISPID_TABSTRIPCTLE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, ITabStripTab* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user has dragged the data out of a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop
			/// target window.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragEnterPotentialTarget, ITabStrip::OLEDrag
			[id(DISPID_TABSTRIPCTLE_OLEDRAGLEAVEPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragLeavePotentialTarget(void);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The tab that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another tab.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoActivateTab If set to \c True, the tab specified by \c dropTarget will be
			///                auto-activated; otherwise not. See the following <strong>remarks</strong> section
			///                for details.
			/// \param[in,out] autoScrollVelocity The speed multiplier for auto-scrolling. If set to 0,
			///                auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls to the left or top (depending on the setting of the \c TabPlacement
			///                property); if set to a value greater than 0, the control auto-scrolls to the right
			///                or bottom. The higher/lower the value is, the faster the control scrolls.\n
			///                This value is ignored, if the \c RegisterForOLEDragDrop property is set to a value
			///                other than \c rfoddAdvancedDragDrop.
			///
			/// \remarks Auto-activation is timered, i. e. the timer is started after this event, if the
			///          \c dropTarget parameter specifies another tab than the last time this event was
			///          fired. Setting the \c autoActivateTab parameter to \c False cancels the timer. If
			///          it isn't canceled, the tab is activated when the timer expires.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, ITabStrip::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, ITabStrip::DragActivateTime, ITabStrip::DragScrollTimeBase,
			///     ITabStrip::DropHilitedTab, ITabStrip::TabPlacement, ITabStrip::SetInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_TABSTRIPCTLE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, ITabStripTab** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoActivateTab, LONG* autoScrollVelocity);
			/// \brief <em>The mouse cursor needs to be updated during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the mouse cursor should be updated to visualize the
			/// current drop effect.
			///
			/// \param[in] effect The current drop effect. It is chosen by the potential drop target.
			///            Any of the values defined by the \c OLEDropEffectConstants enumeration is valid.
			/// \param[in,out] useDefaultCursors If set to \c True, the system's default mouse cursors are
			///                used to visualize the various drop effects. If set to \c False, custom
			///                mouse cursors are used. You must set the custom cursor within the handler of
			///                this event.
			///
			/// \sa ITabStrip::OLEDrag, OLEQueryContinueDrag, OLEDropEffectConstants
			[id(DISPID_TABSTRIPCTLE_OLEGIVEFEEDBACK), helpstring("Will be fired during OLE drag'n'drop if the mouse cursor should be updated.")]
			void OLEGiveFeedback(OLEDropEffectConstants effect, VARIANT_BOOL* useDefaultCursors);
			/// \brief <em>The drag source should decide how to proceed with the OLE drag'n'drop operation</em>
			///
			/// Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed. It
			/// gives the drag source the chance to cancel or complete the drag'n'drop operation.
			///
			/// \param[in] pressedEscape If \c True, the user has pressed the \c ESC key since the last time
			///            this event was fired.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in,out] actionToContinueWith Indicates whether to continue, cancel or complete the
			///                drag'n'drop operation. Any of the values defined by the
			///                \c OLEActionToContinueWithConstants enumeration is valid.
			///
			/// \sa ITabStrip::OLEDrag, OLEGiveFeedback, OLEActionToContinueWithConstants
			[id(DISPID_TABSTRIPCTLE_OLEQUERYCONTINUEDRAG), helpstring("Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed.")]
			void OLEQueryContinueDrag(VARIANT_BOOL pressedEscape, SHORT button, SHORT shift, OLEActionToContinueWithConstants* actionToContinueWith);
			/// \brief <em>Data has been stored in the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data in the specified format has been written into the
			/// dragged data object.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the data object has received data for.
			///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
			///            other format that has been registered using the \c RegisterClipboardFormat API
			///            function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLESetData, IOLEDataObject::GetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_TABSTRIPCTLE_OLERECEIVEDNEWDATA), helpstring("Will be fired during OLE drag'n'drop if data in the specified format has been written into the dragged data object.")]
			void OLEReceivedNewData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>Data is requested from the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data
			/// format, that you've chosen to support (in the \c OLEStartDrag event), but for which you didn't
			/// provide any data so far.\n
			/// Call the provided object's \c SetData method to provide the data. If you chose to not support
			/// this data format, simply do nothing.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the drop target is requesting data
			///            for. Valid values are those defined by VB's \c ClipBoardConstants enumeration, but
			///            also any other format that has been registered using the \c RegisterClipboardFormat
			///            API function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLEStartDrag, IOLEDataObject::SetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_TABSTRIPCTLE_OLESETDATA), helpstring("Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data format, that you've chosen to support (in the 'OLEStartDrag' event), but for which you didn't provide any data so far.")]
			void OLESetData(IOLEDataObject* data, LONG formatID, LONG index, LONG dataOrViewAspect);
			/// \brief <em>The container holding the dragged data needs to be filled up</em>
			///
			/// Will be fired after you called the \c OLEDrag method to determine the data you're offering. You
			/// must call the provided object's \c SetData method for each data format you're offering data in.
			///
			/// \param[in] data The object that holds the dragged data.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa ITabStrip::OLEDrag, OLESetData, OLECompleteDrag, IOLEDataObject::SetData
			[id(DISPID_TABSTRIPCTLE_OLESTARTDRAG), helpstring("Will be fired after you called the 'OLEDrag' method to determine the data you're offering.")]
			void OLEStartDrag(IOLEDataObject* data);
			/// \brief <em>A tab must be drawn in an owner-drawn tabstrip</em>
			///
			/// Will be fired if the \c OwnerDrawn property is set to \c True and a tabstrip tab must be drawn.
			///
			/// \param[in] tsTab The tab to draw.
			/// \param[in] tabState Specifies the tab's current state (e. g. selected). Any of the values
			///            defined by the \c OwnerDrawTabStateConstants enumeration is valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			///
			/// \sa ITabStrip::OwnerDrawn, RECTANGLE, OwnerDrawTabStateConstants
			[id(DISPID_TABSTRIPCTLE_OWNERDRAWTAB), helpstring("Will be fired if the 'OwnerDrawn' property is set to 'True' and a tabstrip tab must be drawn.")]
			void OwnerDrawTab(ITabStripTab* tsTab, OwnerDrawTabStateConstants tabState, LONG hDC, RECTANGLE* drawingRectangle);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] tsTab The tab that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, HitTestConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] tsTab The tab that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, HitTestConstants, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, ITabStrip::hWnd
			[id(DISPID_TABSTRIPCTLE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>A tab was removed</em>
			///
			/// Will be fired after a tab was removed.
			///
			/// \param[in] tsTab The tab that was removed. If \c Nothing, all tabs were removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovingTab, InsertedTab, IVirtualTabStripTab, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_REMOVEDTAB), helpstring("Will be fired after a tab was removed. If 'tsTab' is 'Nothing', all tabs were removed. This event may be disabled.")]
			void RemovedTab(IVirtualTabStripTab* tsTab);
			/// \brief <em>A tab is about to be removed</em>
			///
			/// Will be fired before a tab is removed.
			///
			/// \param[in] tsTab The tab that is about to be removed. If \c Nothing, all tabs are removed.
			/// \param[in,out] cancelDeletion If set to \c True, deletion is aborted, i. e. the tab isn't
			///                removed. If set to \c False, the tab is removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovedTab, InsertingTab, ITabStripTab, ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_REMOVINGTAB), helpstring("Will be fired before a tab is removed. If 'tsTab' is 'Nothing', all tabs are removed. This event may be disabled.")]
			void RemovingTab(ITabStripTab* tsTab, VARIANT_BOOL* cancelDeletion);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_TABSTRIPCTLE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user seems to want to drag a tab</em>
			///
			/// Will be fired if the user seems to want to drag a tab using the left mouse button.
			///
			/// \param[in] tsTab The tab that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa ITabStrip::BeginDrag, ITabStrip::OLEDrag, ITabStrip::AllowDragDrop, TabBeginRDrag,
			///     HitTestConstants
			[id(DISPID_TABSTRIPCTLE_TABBEGINDRAG), helpstring("Will be fired if the user seems to want to drag a tab using the left mouse button.")]
			void TabBeginDrag(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user seems to want to drag a tab</em>
			///
			/// Will be fired if the user seems to want to drag a tab using the right mouse button.
			///
			/// \param[in] tsTab The tab that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbRightButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa ITabStrip::BeginDrag, ITabStrip::OLEDrag, ITabStrip::AllowDragDrop, TabBeginDrag,
			///     HitTestConstants
			[id(DISPID_TABSTRIPCTLE_TABBEGINRDRAG), helpstring("Will be fired if the user seems to want to drag a tab using the right mouse button.")]
			void TabBeginRDrag(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control is about to show the tab's info tip and the text to display is required</em>
			///
			/// Will be fired if the control is about to popup a tooltip to display some information about the
			/// specified tab and requests the text to display.
			///
			/// \param[in] tsTab The tab that the tooltip will be displayed for.
			/// \param[in] maxInfoTipLength The maximum number of characters the info tip text may consist of.
			/// \param[out] infoTipText Set this parameter to the text to display in the tooltip control.
			///
			/// \sa ITabStrip::ShowToolTips
			[id(DISPID_TABSTRIPCTLE_TABGETINFOTIPTEXT), helpstring("Will be fired if the control is about to popup a tooltip to display some information about the specified tab and requests the text to display.")]
			void TabGetInfoTipText(ITabStripTab* tsTab, LONG maxInfoTipLength, BSTR* infoTipText);
			/// \brief <em>The mouse cursor was moved into a tab's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor into the specified tab's bounding rectangle.
			///
			/// \param[in] tsTab The tab that was entered.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa TabMouseLeave, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_TABMOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the specified tab's bounding rectangle. This event may be disabled.")]
			void TabMouseEnter(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of a tab's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor out of the specified tab's bounding rectangle.
			///
			/// \param[in] tsTab The tab that was left.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa TabMouseEnter, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_TABMOUSELEAVE), helpstring("Will be fired if the user moved the mouse cursor out of the specified tab's bounding rectangle. This event may be disabled.")]
			void TabMouseLeave(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A tab's selection state was changed</em>
			///
			/// Will be fired after a tab's selection state was changed.
			///
			/// \param[in] tsTab The tab that was selected/unselected.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ITabStripTab::Selected, ActiveTabChanged, CaretChanged, ITabStrip::MultiSelect,
			///     ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_TABSELECTIONCHANGED), helpstring("Will be fired after a tab's selection state was changed. This event may be disabled.")]
			void TabSelectionChanged(ITabStripTab* tsTab);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] tsTab The tab that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] tsTab The tab that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     ITabStrip::DisabledEvents
			[id(DISPID_TABSTRIPCTLE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(ITabStripTab* tsTab, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \brief <em>The \c TabStrip class</em>
	///
	/// The control's main COM class. It implements the \c ITabStrip and
	/// \c _ITabStripEvents interfaces.
	///
	/// \sa ITabStrip, _ITabStripEvents
	[
		uuid(7BE75005-0B2B-4E45-A648-1763EC5088B3),
		version(1.10),
		helpstring("TabStrip Control 1.10 (ANSI)")
	]
	coclass TabStrip
	{
		[default] interface ITabStrip;
		[default, source] dispinterface _ITabStripEvents;
	};


	/// \interface _IVirtualTabStripTabEvents
	/// \brief <em>The \c VirtualTabStripTab class' events interface</em>
	///
	/// This interface defines all events the \c VirtualTabStripTab class may raise.
	///
	/// \sa IVirtualTabStripTab
	[
		uuid(706FC59A-E8B7-46c3-926C-C28DA297A780),
		helpstring("IVirtualTabStripTab-event-interface")
	]
	dispinterface _IVirtualTabStripTabEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualTabStripTab class</em>
	///
	/// This COM class implements the \c IVirtualTabStripTab and \c _IVirtualTabStripTabEvents
	/// interfaces.
	///
	/// \sa IVirtualTabStripTab, _IVirtualTabStripTabEvents, TabStrip, TabStripTab
	[
		uuid(E5C435A1-1AAE-4489-9F43-4953FFFBCCAA),
		version(1.10),
		noncreatable,
		helpstring("VirtualTabStripTab Class 1.10 (ANSI)")
	]
	coclass VirtualTabStripTab
	{
		[default] interface IVirtualTabStripTab;
		[default, source] dispinterface _IVirtualTabStripTabEvents;
	};


	/// \interface _ITabStripTabEvents
	/// \brief <em>The \c TabStripTab class' events interface</em>
	///
	/// This interface defines all events the \c TabStripTab class may raise.
	///
	/// \sa ITabStripTab
	[
		uuid(2ACD6BD4-C8B8-4d8e-A586-FA236DE405F7),
		helpstring("ITabStripTab-event-interface")
	]
	dispinterface _ITabStripTabEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TabStripTab class</em>
	///
	/// This COM class implements the \c ITabStripTab and \c _ITabStripTabEvents interfaces.
	///
	/// \sa ITabStripTab, _ITabStripTabEvents, TabStrip, TabStripTabs
	[
		uuid(A48586EB-BA8D-458a-8584-2782C947E2D0),
		version(1.10),
		noncreatable,
		helpstring("TabStripTab Class 1.10 (ANSI)")
	]
	coclass TabStripTab
	{
		[default] interface ITabStripTab;
		[default, source] dispinterface _ITabStripTabEvents;
	};


	/// \interface _ITabStripTabsEvents
	/// \brief <em>The \c TabStripTabs class' events interface</em>
	///
	/// This interface defines all events the \c TabStripTabs class may raise.
	///
	/// \sa ITabStripTabs
	[
		uuid(1AB0EEE4-30AA-43e4-A126-1BEFF72D1D58),
		helpstring("ITabStripTabs-event-interface")
	]
	dispinterface _ITabStripTabsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TabStripTabs class</em>
	///
	/// This COM class implements the \c ITabStripTabs and \c _ITabStripTabsEvents interfaces.
	///
	/// \sa ITabStripTabs, _ITabStripTabsEvents, TabStrip, TabStripTab
	[
		uuid(8045F3DC-C660-4d6c-9BB6-7FA4CD09FDEF),
		version(1.10),
		noncreatable,
		helpstring("TabStripTabs Class 1.10 (ANSI)")
	]
	coclass TabStripTabs
	{
		[default] interface ITabStripTabs;
		[default, source] dispinterface _ITabStripTabsEvents;
	};


	/// \interface _ITabStripTabContainerEvents
	/// \brief <em>The \c TabStripTabContainer class' events interface</em>
	///
	/// This interface defines all events the \c TabStripTabContainer class may raise.
	///
	/// \sa ITabStripTabContainer
	[
		uuid(2AF23FEE-2AFF-4d3d-8F0D-23951E459E63),
		helpstring("ITabStripTabContainer-event-interface")
	]
	dispinterface _ITabStripTabContainerEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TabStripTabContainer class</em>
	///
	/// This COM class implements the \c ITabStripTabContainer and \c _ITabStripTabContainerEvents
	/// interfaces.
	///
	/// \sa ITabStripTabContainer, _ITabStripTabContainerEvents, TabStrip, TabStripTab
	[
		uuid(99A4E46A-B01D-4bf8-9318-BB17BE6D7034),
		version(1.10),
		noncreatable,
		helpstring("TabStripTabContainer Class 1.10 (ANSI)")
	]
	coclass TabStripTabContainer
	{
		[default] interface ITabStripTabContainer;
		[default, source] dispinterface _ITabStripTabContainerEvents;
	};


	/// \interface _IOLEDataObjectEvents
	/// \brief <em>The \c OLEDataObject class' events interface</em>
	///
	/// This interface defines all events the \c OLEDataObject class may raise.
	///
	/// \sa IOLEDataObject
	[
		uuid(436DB62F-0218-42de-B121-8F615CEEAE4B),
		helpstring("IOLEDataObject-event-interface")
	]
	dispinterface _IOLEDataObjectEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c OLEDataObject class</em>
	///
	/// This COM class implements the \c IOLEDataObject and \c _IOLEDataObjectEvents interfaces.
	///
	/// \sa IOLEDataObject, _IOLEDataObjectEvents
	[
		uuid(D9B72E05-D9F3-4386-AACD-8F6D65ABC80D),
		version(1.10),
		noncreatable,
		helpstring("OLEDataObject Class 1.10 (ANSI)")
	]
	coclass OLEDataObject
	{
		[default] interface IOLEDataObject;
		[default, source] dispinterface _IOLEDataObjectEvents;
	};


	[
		uuid(5092F8FC-E5E3-4ee9-9086-CFE542AB4121),
		version(1.10),
		noncreatable,
		helpstring("CommonProperties Class 1.10 (ANSI)"),
		hidden
	]
	coclass CommonProperties
	{
		[default] interface IUnknown;
	};
};
